{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\ninterface IOracle {\n    /// @notice Get the latest exchange rate.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function get(bytes calldata data) external returns (bool success, uint256 rate);\n\n    /// @notice Check the last exchange rate without any state changes.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peek(bytes calldata data) external view returns (bool success, uint256 rate);\n\n    /// @notice Check the current spot exchange rate without any state changes. For oracles like TWAP this will be different from peek().\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peekSpot(bytes calldata data) external view returns (uint256 rate);\n\n    /// @notice Returns a human readable (short) name about this oracle.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return (string) A human readable symbol name about this oracle.\n    function symbol(bytes calldata data) external view returns (string memory);\n\n    /// @notice Returns a human readable name about this oracle.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return (string) A human readable name about this oracle.\n    function name(bytes calldata data) external view returns (string memory);\n}\n"
    },
    "contracts/oracles/WbtcOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract WbtcOracle is IOracle {\n    IAggregator public constant BTCUSD = IAggregator(0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n        return 1e16 / uint256(BTCUSD.latestAnswer());\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Chainlink BTC\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/BTC\";\n    }\n}\n"
    },
    "contracts/oracles/AvaxLPOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ncontract AvaxLPOracle is IOracle {\n    IAggregator public constant AVAX = IAggregator(0x0A77230d17318075983913bC2145DB16C7366156);\n\n    /// @dev should be using an implementation of LPChainlinkOracle\n    IAggregator public immutable lpOracle;\n    string private desc;\n\n    constructor(IAggregator _lpOracle, string memory _desc) {\n        lpOracle = _lpOracle;\n        desc = _desc;\n    }\n\n    /// @notice Returns 1 USD price in LP denominated in USD\n    /// @dev lpOracle.latestAnswer() returns the price of 1 LP in AVAX multipled by Avax Price.\n    /// It's then inverted so it gives how many LP can 1 USD buy.\n    function _get() internal view returns (uint256) {\n        uint256 lpPrice = uint256(lpOracle.latestAnswer()) * uint256(AVAX.latestAnswer());\n\n        return 1e44 / lpPrice;\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return desc;\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return desc;\n    }\n}\n"
    },
    "contracts/interfaces/ISwapperGeneric.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ninterface ISwapperGeneric {\n    /// @notice Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\n    /// Swaps it for at least 'amountToMin' of token 'to'.\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\n    /// Returns the amount of tokens 'to' transferred to BentoBox.\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) external returns (uint256 extraShare, uint256 shareReturned);\n\n    /// @notice Calculates the amount of token 'from' needed to complete the swap (amountFrom),\n    /// this should be less than or equal to amountFromMax.\n    /// Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\n    /// Swaps it for exactly 'exactAmountTo' of token 'to'.\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\n    /// Transfers allocated, but unused 'from' tokens within the BentoBox to 'refundTo' (amountFromMax - amountFrom).\n    /// Returns the amount of 'from' tokens withdrawn from BentoBox (amountFrom).\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) external returns (uint256 shareUsed, uint256 shareReturned);\n}\n"
    },
    "contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.4;\n\n/// @notice Babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method).\nlibrary Babylonian {\n    // computes square roots using the babylonian method\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "contracts/convex/IConvexStakingWrapperAbra.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IConvexStakingWrapperAbra {\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n\n    function addRewards() external;\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function cauldrons(uint256) external view returns (address);\n\n    function cauldronsLength() external view returns (uint256);\n\n    function collateralVault() external view returns (address);\n\n    function convexBooster() external view returns (address);\n\n    function convexPool() external view returns (address);\n\n    function convexPoolId() external view returns (uint256);\n\n    function convexToken() external view returns (address);\n\n    function crv() external view returns (address);\n\n    function curveToken() external view returns (address);\n\n    function cvx() external view returns (address);\n\n    function cvx_claimable_reward(address) external view returns (uint256);\n\n    function cvx_reward_integral() external view returns (uint256);\n\n    function cvx_reward_integral_for(address) external view returns (uint256);\n\n    function cvx_reward_remaining() external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n    function deposit(uint256 _amount, address _to) external;\n\n    function earned(address _account) external view returns (EarnedData[] memory claimable);\n\n    function getReward(address _account) external;\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n    function initialize(\n        address _curveToken,\n        address _convexToken,\n        address _convexPool,\n        uint256 _poolId,\n        address _vault\n    ) external;\n\n    function isInit() external view returns (bool);\n\n    function isShutdown() external view returns (bool);\n\n    function name() external view returns (string memory);\n\n    function owner() external view returns (address);\n\n    function renounceOwnership() external;\n\n    function rewardLength() external view returns (uint256);\n\n    function rewards(uint256)\n        external\n        view\n        returns (\n            address reward_token,\n            address reward_pool,\n            uint128 reward_integral,\n            uint128 reward_remaining\n        );\n\n    function setApprovals() external;\n\n    function setCauldron(address _cauldron) external;\n\n    function shutdown() external;\n\n    function stake(uint256 _amount, address _to) external;\n\n    function symbol() external view returns (string memory);\n\n    function totalBalanceOf(address _account) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function transferOwnership(address newOwner) external;\n\n    function user_checkpoint(address[2] calldata _accounts) external returns (bool);\n\n    function withdraw(uint256 _amount) external;\n\n    function withdrawAndUnwrap(uint256 _amount) external;\n}\n"
    },
    "contracts/oracles/aUSTOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n// Chainlink Aggregator\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IExchangeRateFeeder {\n    function exchangeRateOf(address _token, bool _simulate) external view returns (uint256);\n}\n\ncontract aUSTOracle is IExchangeRateFeeder {\n    IAggregator public constant aUST = IAggregator(0x73bB8A4220E5C7Db3E73e4Fcb8d7DCf2efe04805);\n\n    function exchangeRateOf(address, bool) external view returns (uint256) {\n        return uint256(aUST.latestAnswer());\n    }\n}\n"
    },
    "contracts/oracles/AvaxUsdtOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\n/// @title AvaxUsdtOracleV1\n/// @author 0xCalibur\n/// @notice Oracle used for getting the price of 1 USDT in AVAX using Chainlink\ncontract AvaxUsdtOracleV1 is AggregatorV3Interface {\n    AggregatorV3Interface public constant USDTUSD = AggregatorV3Interface(0xEBE676ee90Fe1112671f19b6B7459bC678B67e8a);\n    AggregatorV3Interface public constant AVAXUSD = AggregatorV3Interface(0x0A77230d17318075983913bC2145DB16C7366156);\n\n    function decimals() external pure override returns (uint8) {\n        return 18;\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        (, int256 usdtUsdFeed, , , ) = USDTUSD.latestRoundData();\n        (, int256 avaxUsdFeed, , , ) = AVAXUSD.latestRoundData();\n\n        return (0, (usdtUsdFeed * 1e18) / avaxUsdFeed, 0, 0, 0);\n    }\n}\n"
    },
    "contracts/oracles/LPChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\ninterface IERC20 {\n    function decimals() external pure returns (uint8);\n}\n\ninterface IUniswapV2Pair {\n    function totalSupply() external view returns (uint256);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n}\n\n/// @title LPChainlinkOracleV1\n/// @author BoringCrypto, 0xCalibur\n/// @notice Oracle used for getting the price of an LP token\n/// @dev Optimized version based on https://blog.alphafinance.io/fair-lp-token-pricing/\ncontract LPChainlinkOracleV1 is IAggregator {\n    IUniswapV2Pair public immutable pair;\n    AggregatorV3Interface public immutable tokenOracle;\n    uint8 public immutable token0Decimals;\n    uint8 public immutable token1Decimals;\n    uint8 public immutable oracleDecimals;\n\n    uint256 public constant WAD = 18;\n\n    /// @param pair_ The UniswapV2 compatible pair address\n    /// @param tokenOracle_ The token price 1 lp should be denominated with.\n    constructor(IUniswapV2Pair pair_, AggregatorV3Interface tokenOracle_) {\n        pair = pair_;\n        tokenOracle = tokenOracle_;\n\n        token0Decimals = IERC20(pair_.token0()).decimals();\n        token1Decimals = IERC20(pair_.token1()).decimals();\n\n        oracleDecimals = tokenOracle_.decimals();\n    }\n\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol\n    function sqrt(uint256 x) internal pure returns (uint128) {\n        if (x == 0) return 0;\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return uint128(r < r1 ? r : r1);\n    }\n\n    /// Calculates the lastest exchange rate\n    /// @return the price of 1 lp in token price\n    /// Exemple:\n    /// - For 1 AVAX = $82\n    /// - Total LP Value is: $160,000,000\n    /// - LP supply is 8.25\n    /// - latestAnswer() returns 234420638348190662349201 / 1e18 = 234420.63 AVAX\n    /// - 1 LP = 234420.63 AVAX => 234420.63 * 8.25 * 82 = ≈$160,000,000\n    function latestAnswer() external view override returns (int256) {\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pair).getReserves();\n        uint256 totalSupply = pair.totalSupply();\n\n        uint256 normalizedReserve0 = reserve0 * (10**(WAD - token0Decimals));\n        uint256 normalizedReserve1 = reserve1 * (10**(WAD - token1Decimals));\n\n        uint256 k = normalizedReserve0 * normalizedReserve1;\n        (, int256 priceFeed, , , ) = tokenOracle.latestRoundData();\n\n        uint256 normalizedPriceFeed = uint256(priceFeed) * (10**(WAD - oracleDecimals));\n\n        uint256 totalValue = uint256(sqrt((k / 1e18) * normalizedPriceFeed)) * 2;\n        return int256((totalValue * 1e18) / totalSupply);\n    }\n}\n"
    },
    "contracts/oracles/MimAvaxOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\n/// @title MimAvaxOracleV1\n/// @author 0xCalibur\n/// @notice Oracle used for getting the price of 1 MIM in AVAX using Chainlink\ncontract MimAvaxOracleV1 is AggregatorV3Interface {\n    AggregatorV3Interface public constant MIMUSD = AggregatorV3Interface(0x54EdAB30a7134A16a54218AE64C73e1DAf48a8Fb);\n    AggregatorV3Interface public constant AVAXUSD = AggregatorV3Interface(0x0A77230d17318075983913bC2145DB16C7366156);\n\n    function decimals() external pure override returns (uint8) {\n        return 18;\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        (, int256 mimUsdFeed, , , ) = MIMUSD.latestRoundData();\n        (, int256 avaxUsdFeed, , , ) = AVAXUSD.latestRoundData();\n\n        return (0, (mimUsdFeed * 1e18) / avaxUsdFeed, 0, 0, 0);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}