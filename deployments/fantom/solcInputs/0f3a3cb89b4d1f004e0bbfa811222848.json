{
  "language": "Solidity",
  "sources": {
    "contracts/oracles/FTMOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract FTMOracle is IOracle {\n    IAggregator constant public FTMUSD = IAggregator(0xf4766552D15AE4d256Ad41B6cf2933482B0680dc);\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n\n        return 1e26 / uint256(FTMUSD.latestAnswer());\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Chainlink FTM\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/FTM\";\n    }\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.6.12;\n\ninterface IOracle {\n    /// @notice Get the latest exchange rate.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function get(bytes calldata data) external returns (bool success, uint256 rate);\n\n    /// @notice Check the last exchange rate without any state changes.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peek(bytes calldata data) external view returns (bool success, uint256 rate);\n\n    /// @notice Check the current spot exchange rate without any state changes. For oracles like TWAP this will be different from peek().\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peekSpot(bytes calldata data) external view returns (uint256 rate);\n\n    /// @notice Returns a human readable (short) name about this oracle.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return (string) A human readable symbol name about this oracle.\n    function symbol(bytes calldata data) external view returns (string memory);\n\n    /// @notice Returns a human readable name about this oracle.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return (string) A human readable name about this oracle.\n    function name(bytes calldata data) external view returns (string memory);\n}\n"
    },
    "contracts/swappers/Liquidations/MimAvaxSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/ISwapperGeneric.sol\";\n\ninterface IBentoBoxV1 {\n    function withdraw(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n\n    function deposit(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n}\n\ncontract MimAvaxSwapper is ISwapperGeneric {\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0x1fC83f75499b7620d53757f0b01E2ae626aAE530);\n    IUniswapV2Pair public constant MIMAVAX = IUniswapV2Pair(0xcBb424fd93cDeC0EF330d8A8C985E8b147F62339);\n    IERC20 public constant MIM = IERC20(0x130966628846BFd36ff31a822705796e8cb8C18D);\n    IERC20 public constant WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n\n    constructor() {\n        MIM.approve(address(DEGENBOX), type(uint256).max);\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function _getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapperGeneric\n    function swap(\n        IERC20,\n        IERC20,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n        (uint256 amountFrom, ) = DEGENBOX.withdraw(IERC20(address(MIMAVAX)), address(this), address(this), 0, shareFrom);\n\n        MIMAVAX.transfer(address(MIMAVAX), amountFrom);\n        (uint256 mimAmount, uint256 avaxAmount) = MIMAVAX.burn(address(this));\n\n        // swap AVAX to MIM\n        (uint256 reserve0, uint256 reserve1, ) = MIMAVAX.getReserves();\n        uint256 mimFromAvax = _getAmountOut(avaxAmount, reserve1, reserve0);\n        WAVAX.transfer(address(MIMAVAX), avaxAmount);\n        MIMAVAX.swap(mimFromAvax, 0, address(this), new bytes(0));\n        mimAmount += mimFromAvax;\n\n        (, shareReturned) = DEGENBOX.deposit(MIM, address(this), recipient, mimAmount, 0);\n        extraShare = shareReturned - shareToMin;\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapperGeneric\n    function swapExact(\n        IERC20,\n        IERC20,\n        address,\n        address,\n        uint256,\n        uint256\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0, 0);\n    }\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    },
    "contracts/interfaces/ISwapperGeneric.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.6.12;\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\ninterface ISwapperGeneric {\n    /// @notice Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\n    /// Swaps it for at least 'amountToMin' of token 'to'.\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\n    /// Returns the amount of tokens 'to' transferred to BentoBox.\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) external returns (uint256 extraShare, uint256 shareReturned);\n\n    /// @notice Calculates the amount of token 'from' needed to complete the swap (amountFrom),\n    /// this should be less than or equal to amountFromMax.\n    /// Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\n    /// Swaps it for exactly 'exactAmountTo' of token 'to'.\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\n    /// Transfers allocated, but unused 'from' tokens within the BentoBox to 'refundTo' (amountFromMax - amountFrom).\n    /// Returns the amount of 'from' tokens withdrawn from BentoBox (amountFrom).\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) external returns (uint256 shareUsed, uint256 shareReturned);\n}\n"
    },
    "contracts/swappers/Leverage/MimAvaxLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Router01.sol\";\nimport \"../../libraries/Babylonian.sol\";\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IBentoBoxV1 {\n    function withdraw(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n\n    function deposit(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n}\n\ncontract MimAvaxLevSwapper {\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0x1fC83f75499b7620d53757f0b01E2ae626aAE530);\n    IUniswapV2Pair public constant MIMAVAX = IUniswapV2Pair(0xcBb424fd93cDeC0EF330d8A8C985E8b147F62339);\n    IUniswapV2Router01 public constant ROUTER = IUniswapV2Router01(0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506);\n\n    uint256 private constant DEADLINE = 0xf000000000000000000000000000000000000000000000000000000000000000; // ~ placeholder for swap deadline\n\n    IERC20 public constant MIM = IERC20(0x130966628846BFd36ff31a822705796e8cb8C18D);\n    IERC20 public constant WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n\n    constructor() {\n        MIMAVAX.approve(address(DEGENBOX), type(uint256).max);\n        MIM.approve(address(ROUTER), type(uint256).max);\n        WAVAX.approve(address(ROUTER), type(uint256).max);\n    }\n\n    function _calculateSwapInAmount(uint256 reserveIn, uint256 userIn) internal pure returns (uint256) {\n        return (Babylonian.sqrt(reserveIn * ((userIn * 3988000) + (reserveIn * 3988009))) - (reserveIn * 1997)) / 1994;\n    }\n\n    function _getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n        (uint256 amountFrom, ) = DEGENBOX.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        // Determine optimal amount of AVAX to swap for liquidity providing\n        (uint256 reserve0, uint256 reserve1, ) = MIMAVAX.getReserves();\n        uint256 mimSwapInAmount = _calculateSwapInAmount(reserve0, amountFrom);\n        uint256 avaxAmount = _getAmountOut(mimSwapInAmount, reserve0, reserve1);\n        MIM.transfer(address(MIMAVAX), mimSwapInAmount);\n        MIMAVAX.swap(0, avaxAmount, address(this), \"\");\n\n        ROUTER.addLiquidity(\n            address(MIM),\n            address(WAVAX),\n            MIM.balanceOf(address(this)),\n            WAVAX.balanceOf(address(this)),\n            1,\n            1,\n            address(this),\n            DEADLINE\n        );\n\n        (, shareReturned) = DEGENBOX.deposit(IERC20(address(MIMAVAX)), address(this), recipient, MIMAVAX.balanceOf(address(this)), 0);\n        extraShare = shareReturned - shareToMin;\n    }\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}"
    },
    "contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.4;\n\n/// @notice Babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method).\nlibrary Babylonian {\n    // computes square roots using the babylonian method\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}