{
  "language": "Solidity",
  "sources": {
    "contracts/CauldronV2MultiChain.sol": {
      "content": "// SPDX-License-Identifier: MIXED\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.2\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n/// @notice A library for performing overflow-/underflow-safe math,\r\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\r\nlibrary BoringMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\r\n    }\r\n\r\n    function to128(uint256 a) internal pure returns (uint128 c) {\r\n        require(a <= uint128(-1), \"BoringMath: uint128 Overflow\");\r\n        c = uint128(a);\r\n    }\r\n\r\n    function to64(uint256 a) internal pure returns (uint64 c) {\r\n        require(a <= uint64(-1), \"BoringMath: uint64 Overflow\");\r\n        c = uint64(a);\r\n    }\r\n\r\n    function to32(uint256 a) internal pure returns (uint32 c) {\r\n        require(a <= uint32(-1), \"BoringMath: uint32 Overflow\");\r\n        c = uint32(a);\r\n    }\r\n}\r\n\r\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\r\nlibrary BoringMath128 {\r\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n}\r\n\r\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.\r\nlibrary BoringMath64 {\r\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n}\r\n\r\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\r\nlibrary BoringMath32 {\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/BoringOwnable.sol@v1.2.2\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\r\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\r\n// Edited by BoringCrypto\r\n\r\ncontract BoringOwnableData {\r\n    address public owner;\r\n    address public pendingOwner;\r\n}\r\n\r\ncontract BoringOwnable is BoringOwnableData {\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice `owner` defaults to msg.sender on construction.\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\r\n    /// Can only be invoked by the current `owner`.\r\n    /// @param newOwner Address of the new owner.\r\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\r\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\r\n    function transferOwnership(\r\n        address newOwner,\r\n        bool direct,\r\n        bool renounce\r\n    ) public onlyOwner {\r\n        if (direct) {\r\n            // Checks\r\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\r\n\r\n            // Effects\r\n            emit OwnershipTransferred(owner, newOwner);\r\n            owner = newOwner;\r\n            pendingOwner = address(0);\r\n        } else {\r\n            // Effects\r\n            pendingOwner = newOwner;\r\n        }\r\n    }\r\n\r\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\r\n    function claimOwnership() public {\r\n        address _pendingOwner = pendingOwner;\r\n\r\n        // Checks\r\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\r\n\r\n        // Effects\r\n        emit OwnershipTransferred(owner, _pendingOwner);\r\n        owner = _pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n\r\n    /// @notice Only allows the `owner` to execute the function.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.2\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /// @notice EIP 2612\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/Domain.sol@v1.2.2\r\n// License-Identifier: MIT\r\n// Based on code and smartness by Ross Campbell and Keno\r\n// Uses immutable to store the domain separator to reduce gas usage\r\n// If the chain id changes due to a fork, the forked chain will calculate on the fly.\r\npragma solidity 0.6.12;\r\n\r\n// solhint-disable no-inline-assembly\r\n\r\ncontract Domain {\r\n    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\r\n    // See https://eips.ethereum.org/EIPS/eip-191\r\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = \"\\x19\\x01\";\r\n\r\n    // solhint-disable var-name-mixedcase\r\n    bytes32 private immutable _DOMAIN_SEPARATOR;\r\n    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;    \r\n\r\n    /// @dev Calculate the DOMAIN_SEPARATOR\r\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\r\n        return keccak256(\r\n            abi.encode(\r\n                DOMAIN_SEPARATOR_SIGNATURE_HASH,\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    constructor() public {\r\n        uint256 chainId; assembly {chainId := chainid()}\r\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);\r\n    }\r\n\r\n    /// @dev Return the DOMAIN_SEPARATOR\r\n    // It's named internal to allow making it public from the contract that uses it by creating a simple view function\r\n    // with the desired public name, such as DOMAIN_SEPARATOR or domainSeparator.\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function _domainSeparator() internal view returns (bytes32) {\r\n        uint256 chainId; assembly {chainId := chainid()}\r\n        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\r\n    }\r\n\r\n    function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {\r\n        digest =\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,\r\n                    _domainSeparator(),\r\n                    dataHash\r\n                )\r\n            );\r\n    }\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/ERC20.sol@v1.2.2\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n\r\n// solhint-disable no-inline-assembly\r\n// solhint-disable not-rely-on-time\r\n\r\n// Data part taken out for building of contracts that receive delegate calls\r\ncontract ERC20Data {\r\n    /// @notice owner > balance mapping.\r\n    mapping(address => uint256) public balanceOf;\r\n    /// @notice owner > spender > allowance mapping.\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    /// @notice owner > nonce mapping. Used in `permit`.\r\n    mapping(address => uint256) public nonces;\r\n}\r\n\r\nabstract contract ERC20 is IERC20, Domain {\r\n    /// @notice owner > balance mapping.\r\n    mapping(address => uint256) public override balanceOf;\r\n    /// @notice owner > spender > allowance mapping.\r\n    mapping(address => mapping(address => uint256)) public override allowance;\r\n    /// @notice owner > nonce mapping. Used in `permit`.\r\n    mapping(address => uint256) public nonces;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /// @notice Transfers `amount` tokens from `msg.sender` to `to`.\r\n    /// @param to The address to move the tokens.\r\n    /// @param amount of the tokens to move.\r\n    /// @return (bool) Returns True if succeeded.\r\n    function transfer(address to, uint256 amount) public returns (bool) {\r\n        // If `amount` is 0, or `msg.sender` is `to` nothing happens\r\n        if (amount != 0 || msg.sender == to) {\r\n            uint256 srcBalance = balanceOf[msg.sender];\r\n            require(srcBalance >= amount, \"ERC20: balance too low\");\r\n            if (msg.sender != to) {\r\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\r\n\r\n                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\r\n                balanceOf[to] += amount;\r\n            }\r\n        }\r\n        emit Transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.\r\n    /// @param from Address to draw tokens from.\r\n    /// @param to The address to move the tokens.\r\n    /// @param amount The token amount to move.\r\n    /// @return (bool) Returns True if succeeded.\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public returns (bool) {\r\n        // If `amount` is 0, or `from` is `to` nothing happens\r\n        if (amount != 0) {\r\n            uint256 srcBalance = balanceOf[from];\r\n            require(srcBalance >= amount, \"ERC20: balance too low\");\r\n\r\n            if (from != to) {\r\n                uint256 spenderAllowance = allowance[from][msg.sender];\r\n                // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\r\n                if (spenderAllowance != type(uint256).max) {\r\n                    require(spenderAllowance >= amount, \"ERC20: allowance too low\");\r\n                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\r\n                }\r\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\r\n\r\n                balanceOf[from] = srcBalance - amount; // Underflow is checked\r\n                balanceOf[to] += amount;\r\n            }\r\n        }\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Approves `amount` from sender to be spend by `spender`.\r\n    /// @param spender Address of the party that can draw from msg.sender's account.\r\n    /// @param amount The maximum collective amount that `spender` can draw.\r\n    /// @return (bool) Returns True if approved.\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\r\n        return _domainSeparator();\r\n    }\r\n\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\r\n    /// @notice Approves `value` from `owner_` to be spend by `spender`.\r\n    /// @param owner_ Address of the owner.\r\n    /// @param spender The address of the spender that gets approved to draw from `owner_`.\r\n    /// @param value The maximum collective amount that `spender` can draw.\r\n    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\r\n    function permit(\r\n        address owner_,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external override {\r\n        require(owner_ != address(0), \"ERC20: Owner cannot be 0\");\r\n        require(block.timestamp < deadline, \"ERC20: Expired\");\r\n        require(\r\n            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\r\n                owner_,\r\n            \"ERC20: Invalid Signature\"\r\n        );\r\n        allowance[owner_][spender] = value;\r\n        emit Approval(owner_, spender, value);\r\n    }\r\n}\r\n\r\ncontract ERC20WithSupply is IERC20, ERC20 {\r\n    uint256 public override totalSupply;\r\n\r\n    function _mint(address user, uint256 amount) private {\r\n        uint256 newTotalSupply = totalSupply + amount;\r\n        require(newTotalSupply >= totalSupply, \"Mint overflow\");\r\n        totalSupply = newTotalSupply;\r\n        balanceOf[user] += amount;\r\n    }\r\n\r\n    function _burn(address user, uint256 amount) private {\r\n        require(balanceOf[user] >= amount, \"Burn too much\");\r\n        totalSupply -= amount;\r\n        balanceOf[user] -= amount;\r\n    }\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol@v1.2.2\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IMasterContract {\r\n    /// @notice Init function that gets called from `BoringFactory.deploy`.\r\n    /// Also kown as the constructor for cloned contracts.\r\n    /// Any ETH send to `BoringFactory.deploy` ends up here.\r\n    /// @param data Can be abi encoded arguments or anything else.\r\n    function init(bytes calldata data) external payable;\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol@v1.2.2\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nstruct Rebase {\r\n    uint128 elastic;\r\n    uint128 base;\r\n}\r\n\r\n/// @notice A rebasing library using overflow-/underflow-safe math.\r\nlibrary RebaseLibrary {\r\n    using BoringMath for uint256;\r\n    using BoringMath128 for uint128;\r\n\r\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\r\n    function toBase(\r\n        Rebase memory total,\r\n        uint256 elastic,\r\n        bool roundUp\r\n    ) internal pure returns (uint256 base) {\r\n        if (total.elastic == 0) {\r\n            base = elastic;\r\n        } else {\r\n            base = elastic.mul(total.base) / total.elastic;\r\n            if (roundUp && base.mul(total.elastic) / total.base < elastic) {\r\n                base = base.add(1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\r\n    function toElastic(\r\n        Rebase memory total,\r\n        uint256 base,\r\n        bool roundUp\r\n    ) internal pure returns (uint256 elastic) {\r\n        if (total.base == 0) {\r\n            elastic = base;\r\n        } else {\r\n            elastic = base.mul(total.elastic) / total.base;\r\n            if (roundUp && elastic.mul(total.base) / total.elastic < base) {\r\n                elastic = elastic.add(1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\r\n    /// @return (Rebase) The new total.\r\n    /// @return base in relationship to `elastic`.\r\n    function add(\r\n        Rebase memory total,\r\n        uint256 elastic,\r\n        bool roundUp\r\n    ) internal pure returns (Rebase memory, uint256 base) {\r\n        base = toBase(total, elastic, roundUp);\r\n        total.elastic = total.elastic.add(elastic.to128());\r\n        total.base = total.base.add(base.to128());\r\n        return (total, base);\r\n    }\r\n\r\n    /// @notice Sub `base` from `total` and update `total.elastic`.\r\n    /// @return (Rebase) The new total.\r\n    /// @return elastic in relationship to `base`.\r\n    function sub(\r\n        Rebase memory total,\r\n        uint256 base,\r\n        bool roundUp\r\n    ) internal pure returns (Rebase memory, uint256 elastic) {\r\n        elastic = toElastic(total, base, roundUp);\r\n        total.elastic = total.elastic.sub(elastic.to128());\r\n        total.base = total.base.sub(base.to128());\r\n        return (total, elastic);\r\n    }\r\n\r\n    /// @notice Add `elastic` and `base` to `total`.\r\n    function add(\r\n        Rebase memory total,\r\n        uint256 elastic,\r\n        uint256 base\r\n    ) internal pure returns (Rebase memory) {\r\n        total.elastic = total.elastic.add(elastic.to128());\r\n        total.base = total.base.add(base.to128());\r\n        return total;\r\n    }\r\n\r\n    /// @notice Subtract `elastic` and `base` to `total`.\r\n    function sub(\r\n        Rebase memory total,\r\n        uint256 elastic,\r\n        uint256 base\r\n    ) internal pure returns (Rebase memory) {\r\n        total.elastic = total.elastic.sub(elastic.to128());\r\n        total.base = total.base.sub(base.to128());\r\n        return total;\r\n    }\r\n\r\n    /// @notice Add `elastic` to `total` and update storage.\r\n    /// @return newElastic Returns updated `elastic`.\r\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\r\n        newElastic = total.elastic = total.elastic.add(elastic.to128());\r\n    }\r\n\r\n    /// @notice Subtract `elastic` from `total` and update storage.\r\n    /// @return newElastic Returns updated `elastic`.\r\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\r\n        newElastic = total.elastic = total.elastic.sub(elastic.to128());\r\n    }\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.2\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n// solhint-disable avoid-low-level-calls\r\n\r\nlibrary BoringERC20 {\r\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\r\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\r\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\r\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\r\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\r\n\r\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\r\n        if (data.length >= 64) {\r\n            return abi.decode(data, (string));\r\n        } else if (data.length == 32) {\r\n            uint8 i = 0;\r\n            while(i < 32 && data[i] != 0) {\r\n                i++;\r\n            }\r\n            bytes memory bytesArray = new bytes(i);\r\n            for (i = 0; i < 32 && data[i] != 0; i++) {\r\n                bytesArray[i] = data[i];\r\n            }\r\n            return string(bytesArray);\r\n        } else {\r\n            return \"???\";\r\n        }\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\r\n    /// @param token The address of the ERC-20 token contract.\r\n    /// @return (string) Token symbol.\r\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\r\n        return success ? returnDataToString(data) : \"???\";\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\r\n    /// @param token The address of the ERC-20 token contract.\r\n    /// @return (string) Token name.\r\n    function safeName(IERC20 token) internal view returns (string memory) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\r\n        return success ? returnDataToString(data) : \"???\";\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\r\n    /// @param token The address of the ERC-20 token contract.\r\n    /// @return (uint8) Token decimals.\r\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\r\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\r\n    /// Reverts on a failed transfer.\r\n    /// @param token The address of the ERC-20 token.\r\n    /// @param to Transfer tokens to.\r\n    /// @param amount The token amount.\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\r\n    /// Reverts on a failed transfer.\r\n    /// @param token The address of the ERC-20 token.\r\n    /// @param from Transfer tokens from.\r\n    /// @param to Transfer tokens to.\r\n    /// @param amount The token amount.\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\r\n    }\r\n}\r\n\r\n// File @sushiswap/bentobox-sdk/contracts/IBatchFlashBorrower.sol@v1.0.2\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IBatchFlashBorrower {\r\n    function onBatchFlashLoan(\r\n        address sender,\r\n        IERC20[] calldata tokens,\r\n        uint256[] calldata amounts,\r\n        uint256[] calldata fees,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File @sushiswap/bentobox-sdk/contracts/IFlashBorrower.sol@v1.0.2\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IFlashBorrower {\r\n    function onFlashLoan(\r\n        address sender,\r\n        IERC20 token,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File @sushiswap/bentobox-sdk/contracts/IStrategy.sol@v1.0.2\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IStrategy {\r\n    // Send the assets to the Strategy and call skim to invest them\r\n    function skim(uint256 amount) external;\r\n\r\n    // Harvest any profits made converted to the asset and pass them to the caller\r\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\r\n\r\n    // Withdraw assets. The returned amount can differ from the requested amount due to rounding.\r\n    // The actualAmount should be very close to the amount. The difference should NOT be used to report a loss. That's what harvest is for.\r\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\r\n\r\n    // Withdraw all assets in the safest way possible. This shouldn't fail.\r\n    function exit(uint256 balance) external returns (int256 amountAdded);\r\n}\r\n\r\n// File @sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol@v1.0.2\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\ninterface IBentoBoxV1 {\r\n    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);\r\n    event LogDeposit(address indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\r\n    event LogFlashLoan(address indexed borrower, address indexed token, uint256 amount, uint256 feeAmount, address indexed receiver);\r\n    event LogRegisterProtocol(address indexed protocol);\r\n    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool approved);\r\n    event LogStrategyDivest(address indexed token, uint256 amount);\r\n    event LogStrategyInvest(address indexed token, uint256 amount);\r\n    event LogStrategyLoss(address indexed token, uint256 amount);\r\n    event LogStrategyProfit(address indexed token, uint256 amount);\r\n    event LogStrategyQueued(address indexed token, address indexed strategy);\r\n    event LogStrategySet(address indexed token, address indexed strategy);\r\n    event LogStrategyTargetPercentage(address indexed token, uint256 targetPercentage);\r\n    event LogTransfer(address indexed token, address indexed from, address indexed to, uint256 share);\r\n    event LogWhiteListMasterContract(address indexed masterContract, bool approved);\r\n    event LogWithdraw(address indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    function balanceOf(IERC20, address) external view returns (uint256);\r\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);\r\n    function batchFlashLoan(IBatchFlashBorrower borrower, address[] calldata receivers, IERC20[] calldata tokens, uint256[] calldata amounts, bytes calldata data) external;\r\n    function claimOwnership() external;\r\n    function deploy(address masterContract, bytes calldata data, bool useCreate2) external payable;\r\n    function deposit(IERC20 token_, address from, address to, uint256 amount, uint256 share) external payable returns (uint256 amountOut, uint256 shareOut);\r\n    function flashLoan(IFlashBorrower borrower, address receiver, IERC20 token, uint256 amount, bytes calldata data) external;\r\n    function harvest(IERC20 token, bool balance, uint256 maxChangeAmount) external;\r\n    function masterContractApproved(address, address) external view returns (bool);\r\n    function masterContractOf(address) external view returns (address);\r\n    function nonces(address) external view returns (uint256);\r\n    function owner() external view returns (address);\r\n    function pendingOwner() external view returns (address);\r\n    function pendingStrategy(IERC20) external view returns (IStrategy);\r\n    function permitToken(IERC20 token, address from, address to, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    function registerProtocol() external;\r\n    function setMasterContractApproval(address user, address masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) external;\r\n    function setStrategy(IERC20 token, IStrategy newStrategy) external;\r\n    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) external;\r\n    function strategy(IERC20) external view returns (IStrategy);\r\n    function strategyData(IERC20) external view returns (uint64 strategyStartDate, uint64 targetPercentage, uint128 balance);\r\n    function toAmount(IERC20 token, uint256 share, bool roundUp) external view returns (uint256 amount);\r\n    function toShare(IERC20 token, uint256 amount, bool roundUp) external view returns (uint256 share);\r\n    function totals(IERC20) external view returns (Rebase memory totals_);\r\n    function transfer(IERC20 token, address from, address to, uint256 share) external;\r\n    function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) external;\r\n    function transferOwnership(address newOwner, bool direct, bool renounce) external;\r\n    function whitelistMasterContract(address masterContract, bool approved) external;\r\n    function whitelistedMasterContracts(address) external view returns (bool);\r\n    function withdraw(IERC20 token_, address from, address to, uint256 amount, uint256 share) external returns (uint256 amountOut, uint256 shareOut);\r\n}\r\n\r\n// File contracts/MagicInternetMoney.sol\r\n// License-Identifier: MIT\r\n\r\n// Magic Internet Money\r\n\r\n// ███╗   ███╗██╗███╗   ███╗\r\n// ████╗ ████║██║████╗ ████║\r\n// ██╔████╔██║██║██╔████╔██║\r\n// ██║╚██╔╝██║██║██║╚██╔╝██║\r\n// ██║ ╚═╝ ██║██║██║ ╚═╝ ██║\r\n// ╚═╝     ╚═╝╚═╝╚═╝     ╚═╝\r\n\r\n// BoringCrypto, 0xMerlin\r\n\r\npragma solidity 0.6.12;\r\n/// @title Cauldron\r\n/// @dev This contract allows contract calls to any contract (except BentoBox)\r\n/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.\r\ncontract MagicInternetMoney is ERC20, BoringOwnable {\r\n    using BoringMath for uint256;\r\n    // ERC20 'variables'\r\n    string public constant symbol = \"MIM\";\r\n    string public constant name = \"Magic Internet Money\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public override totalSupply;\r\n\r\n    struct Minting {\r\n        uint128 time;\r\n        uint128 amount;\r\n    }\r\n\r\n    Minting public lastMint;\r\n    uint256 private constant MINTING_PERIOD = 24 hours;\r\n    uint256 private constant MINTING_INCREASE = 15000;\r\n    uint256 private constant MINTING_PRECISION = 1e5;\r\n\r\n    function mint(address to, uint256 amount) public onlyOwner {\r\n        require(to != address(0), \"MIM: no mint to zero address\");\r\n\r\n        // Limits the amount minted per period to a convergence function, with the period duration restarting on every mint\r\n        uint256 totalMintedAmount = uint256(lastMint.time < block.timestamp - MINTING_PERIOD ? 0 : lastMint.amount).add(amount);\r\n        require(totalSupply == 0 || totalSupply.mul(MINTING_INCREASE) / MINTING_PRECISION >= totalMintedAmount);\r\n\r\n        lastMint.time = block.timestamp.to128();\r\n        lastMint.amount = totalMintedAmount.to128();\r\n\r\n        totalSupply = totalSupply + amount;\r\n        balanceOf[to] += amount;\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function mintToBentoBox(address clone, uint256 amount, IBentoBoxV1 bentoBox) public onlyOwner {\r\n        mint(address(bentoBox), amount);\r\n        bentoBox.deposit(IERC20(address(this)), address(bentoBox), clone, amount, 0);\r\n    }\r\n\r\n    function burn(uint256 amount) public {\r\n        require(amount <= balanceOf[msg.sender], \"MIM: not enough\");\r\n\r\n        balanceOf[msg.sender] -= amount;\r\n        totalSupply -= amount;\r\n        emit Transfer(msg.sender, address(0), amount);\r\n    }\r\n}\r\n\r\n// File contracts/interfaces/IOracle.sol\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IOracle {\r\n    /// @notice Get the latest exchange rate.\r\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\r\n    /// For example:\r\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\r\n    /// @return success if no valid (recent) rate is available, return false else true.\r\n    /// @return rate The rate of the requested asset / pair / pool.\r\n    function get(bytes calldata data) external returns (bool success, uint256 rate);\r\n\r\n    /// @notice Check the last exchange rate without any state changes.\r\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\r\n    /// For example:\r\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\r\n    /// @return success if no valid (recent) rate is available, return false else true.\r\n    /// @return rate The rate of the requested asset / pair / pool.\r\n    function peek(bytes calldata data) external view returns (bool success, uint256 rate);\r\n\r\n    /// @notice Check the current spot exchange rate without any state changes. For oracles like TWAP this will be different from peek().\r\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\r\n    /// For example:\r\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\r\n    /// @return rate The rate of the requested asset / pair / pool.\r\n    function peekSpot(bytes calldata data) external view returns (uint256 rate);\r\n\r\n    /// @notice Returns a human readable (short) name about this oracle.\r\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\r\n    /// For example:\r\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\r\n    /// @return (string) A human readable symbol name about this oracle.\r\n    function symbol(bytes calldata data) external view returns (string memory);\r\n\r\n    /// @notice Returns a human readable name about this oracle.\r\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\r\n    /// For example:\r\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\r\n    /// @return (string) A human readable name about this oracle.\r\n    function name(bytes calldata data) external view returns (string memory);\r\n}\r\n\r\n// File contracts/interfaces/ISwapper.sol\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface ISwapper {\r\n    /// @notice Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\r\n    /// Swaps it for at least 'amountToMin' of token 'to'.\r\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\r\n    /// Returns the amount of tokens 'to' transferred to BentoBox.\r\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\r\n    function swap(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        address recipient,\r\n        uint256 shareToMin,\r\n        uint256 shareFrom\r\n    ) external returns (uint256 extraShare, uint256 shareReturned);\r\n\r\n    /// @notice Calculates the amount of token 'from' needed to complete the swap (amountFrom),\r\n    /// this should be less than or equal to amountFromMax.\r\n    /// Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\r\n    /// Swaps it for exactly 'exactAmountTo' of token 'to'.\r\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\r\n    /// Transfers allocated, but unused 'from' tokens within the BentoBox to 'refundTo' (amountFromMax - amountFrom).\r\n    /// Returns the amount of 'from' tokens withdrawn from BentoBox (amountFrom).\r\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\r\n    function swapExact(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        address recipient,\r\n        address refundTo,\r\n        uint256 shareFromSupplied,\r\n        uint256 shareToExact\r\n    ) external returns (uint256 shareUsed, uint256 shareReturned);\r\n}\r\n\r\n// File contracts/CauldronV2MultiChain.sol\r\n// License-Identifier: UNLICENSED\r\n\r\n// Cauldron\r\n\r\n//    (                (   (\r\n//    )\\      )    (   )\\  )\\ )  (\r\n//  (((_)  ( /(   ))\\ ((_)(()/(  )(    (    (\r\n//  )\\___  )(_)) /((_) _   ((_))(()\\   )\\   )\\ )\r\n// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(\r\n//  | (__ / _` || || || |/ _` | | '_|/ _ \\| ' \\))\r\n//   \\___|\\__,_| \\_,_||_|\\__,_| |_|  \\___/|_||_|\r\n\r\n// Copyright (c) 2021 BoringCrypto - All rights reserved\r\n// Twitter: @Boring_Crypto\r\n\r\n// Special thanks to:\r\n// @0xKeno - for all his invaluable contributions\r\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n// solhint-disable avoid-low-level-calls\r\n// solhint-disable no-inline-assembly\r\n\r\n/// @title Cauldron\r\n/// @dev This contract allows contract calls to any contract (except BentoBox)\r\n/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.\r\ncontract CauldronV2Multichain is BoringOwnable, IMasterContract {\r\n    using BoringMath for uint256;\r\n    using BoringMath128 for uint128;\r\n    using RebaseLibrary for Rebase;\r\n    using BoringERC20 for IERC20;\r\n\r\n    event LogExchangeRate(uint256 rate);\r\n    event LogAccrue(uint128 accruedAmount);\r\n    event LogAddCollateral(address indexed from, address indexed to, uint256 share);\r\n    event LogRemoveCollateral(address indexed from, address indexed to, uint256 share);\r\n    event LogBorrow(address indexed from, address indexed to, uint256 amount, uint256 part);\r\n    event LogRepay(address indexed from, address indexed to, uint256 amount, uint256 part);\r\n    event LogFeeTo(address indexed newFeeTo);\r\n    event LogWithdrawFees(address indexed feeTo, uint256 feesEarnedFraction);\r\n\r\n    // Immutables (for MasterContract and all clones)\r\n    IBentoBoxV1 public immutable bentoBox;\r\n    CauldronV2Multichain public immutable masterContract;\r\n    IERC20 public immutable magicInternetMoney;\r\n\r\n    // MasterContract variables\r\n    address public feeTo;\r\n\r\n    // Per clone variables\r\n    // Clone init settings\r\n    IERC20 public collateral;\r\n    IOracle public oracle;\r\n    bytes public oracleData;\r\n\r\n    // Total amounts\r\n    uint256 public totalCollateralShare; // Total collateral supplied\r\n    Rebase public totalBorrow; // elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers\r\n\r\n    // User balances\r\n    mapping(address => uint256) public userCollateralShare;\r\n    mapping(address => uint256) public userBorrowPart;\r\n\r\n    /// @notice Exchange and interest rate tracking.\r\n    /// This is 'cached' here because calls to Oracles can be very expensive.\r\n    uint256 public exchangeRate;\r\n\r\n    struct AccrueInfo {\r\n        uint64 lastAccrued;\r\n        uint128 feesEarned;\r\n        uint64 INTEREST_PER_SECOND;\r\n    }\r\n\r\n    AccrueInfo public accrueInfo;\r\n\r\n    // Settings\r\n    uint256 public COLLATERIZATION_RATE;\r\n    uint256 private constant COLLATERIZATION_RATE_PRECISION = 1e5; // Must be less than EXCHANGE_RATE_PRECISION (due to optimization in math)\r\n\r\n    uint256 private constant EXCHANGE_RATE_PRECISION = 1e18;\r\n\r\n    uint256 public LIQUIDATION_MULTIPLIER; \r\n    uint256 private constant LIQUIDATION_MULTIPLIER_PRECISION = 1e5;\r\n\r\n    uint256 public BORROW_OPENING_FEE;\r\n    uint256 private constant BORROW_OPENING_FEE_PRECISION = 1e5;\r\n\r\n    uint256 private constant DISTRIBUTION_PART = 10;\r\n    uint256 private constant DISTRIBUTION_PRECISION = 100;\r\n\r\n    /// @notice The constructor is only used for the initial master contract. Subsequent clones are initialised via `init`.\r\n    constructor(IBentoBoxV1 bentoBox_, IERC20 magicInternetMoney_) public {\r\n        bentoBox = bentoBox_;\r\n        magicInternetMoney = magicInternetMoney_;\r\n        masterContract = this;\r\n    }\r\n\r\n    /// @notice Serves as the constructor for clones, as clones can't have a regular constructor\r\n    /// @dev `data` is abi encoded in the format: (IERC20 collateral, IERC20 asset, IOracle oracle, bytes oracleData)\r\n    function init(bytes calldata data) public payable override {\r\n        require(address(collateral) == address(0), \"Cauldron: already initialized\");\r\n        (collateral, oracle, oracleData, accrueInfo.INTEREST_PER_SECOND, LIQUIDATION_MULTIPLIER, COLLATERIZATION_RATE, BORROW_OPENING_FEE) = abi.decode(data, (IERC20, IOracle, bytes, uint64, uint256, uint256, uint256));\r\n        require(address(collateral) != address(0), \"Cauldron: bad pair\");\r\n    }\r\n\r\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\r\n    function accrue() public {\r\n        AccrueInfo memory _accrueInfo = accrueInfo;\r\n        // Number of seconds since accrue was called\r\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\r\n        if (elapsedTime == 0) {\r\n            return;\r\n        }\r\n        _accrueInfo.lastAccrued = uint64(block.timestamp);\r\n\r\n        Rebase memory _totalBorrow = totalBorrow;\r\n        if (_totalBorrow.base == 0) {\r\n            accrueInfo = _accrueInfo;\r\n            return;\r\n        }\r\n\r\n        // Accrue interest\r\n        uint128 extraAmount = (uint256(_totalBorrow.elastic).mul(_accrueInfo.INTEREST_PER_SECOND).mul(elapsedTime) / 1e18).to128();\r\n        _totalBorrow.elastic = _totalBorrow.elastic.add(extraAmount);\r\n\r\n        _accrueInfo.feesEarned = _accrueInfo.feesEarned.add(extraAmount);\r\n        totalBorrow = _totalBorrow;\r\n        accrueInfo = _accrueInfo;\r\n\r\n        emit LogAccrue(extraAmount);\r\n    }\r\n\r\n    /// @notice Concrete implementation of `isSolvent`. Includes a third parameter to allow caching `exchangeRate`.\r\n    /// @param _exchangeRate The exchange rate. Used to cache the `exchangeRate` between calls.\r\n    function _isSolvent(address user, uint256 _exchangeRate) internal view returns (bool) {\r\n        // accrue must have already been called!\r\n        uint256 borrowPart = userBorrowPart[user];\r\n        if (borrowPart == 0) return true;\r\n        uint256 collateralShare = userCollateralShare[user];\r\n        if (collateralShare == 0) return false;\r\n\r\n        Rebase memory _totalBorrow = totalBorrow;\r\n\r\n        return\r\n            bentoBox.toAmount(\r\n                collateral,\r\n                collateralShare.mul(EXCHANGE_RATE_PRECISION / COLLATERIZATION_RATE_PRECISION).mul(COLLATERIZATION_RATE),\r\n                false\r\n            ) >=\r\n            // Moved exchangeRate here instead of dividing the other side to preserve more precision\r\n            borrowPart.mul(_totalBorrow.elastic).mul(_exchangeRate) / _totalBorrow.base;\r\n    }\r\n\r\n    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.\r\n    modifier solvent() {\r\n        _;\r\n        require(_isSolvent(msg.sender, exchangeRate), \"Cauldron: user insolvent\");\r\n    }\r\n\r\n    /// @notice Gets the exchange rate. I.e how much collateral to buy 1e18 asset.\r\n    /// This function is supposed to be invoked if needed because Oracle queries can be expensive.\r\n    /// @return updated True if `exchangeRate` was updated.\r\n    /// @return rate The new exchange rate.\r\n    function updateExchangeRate() public returns (bool updated, uint256 rate) {\r\n        (updated, rate) = oracle.get(oracleData);\r\n\r\n        if (updated) {\r\n            exchangeRate = rate;\r\n            emit LogExchangeRate(rate);\r\n        } else {\r\n            // Return the old rate if fetching wasn't successful\r\n            rate = exchangeRate;\r\n        }\r\n    }\r\n\r\n    /// @dev Helper function to move tokens.\r\n    /// @param token The ERC-20 token.\r\n    /// @param share The amount in shares to add.\r\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\r\n    /// Only used for accounting checks.\r\n    /// @param skim If True, only does a balance check on this contract.\r\n    /// False if tokens from msg.sender in `bentoBox` should be transferred.\r\n    function _addTokens(\r\n        IERC20 token,\r\n        uint256 share,\r\n        uint256 total,\r\n        bool skim\r\n    ) internal {\r\n        if (skim) {\r\n            require(share <= bentoBox.balanceOf(token, address(this)).sub(total), \"Cauldron: Skim too much\");\r\n        } else {\r\n            bentoBox.transfer(token, msg.sender, address(this), share);\r\n        }\r\n    }\r\n\r\n    /// @notice Adds `collateral` from msg.sender to the account `to`.\r\n    /// @param to The receiver of the tokens.\r\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.x\r\n    /// False if tokens from msg.sender in `bentoBox` should be transferred.\r\n    /// @param share The amount of shares to add for `to`.\r\n    function addCollateral(\r\n        address to,\r\n        bool skim,\r\n        uint256 share\r\n    ) public {\r\n        userCollateralShare[to] = userCollateralShare[to].add(share);\r\n        uint256 oldTotalCollateralShare = totalCollateralShare;\r\n        totalCollateralShare = oldTotalCollateralShare.add(share);\r\n        _addTokens(collateral, share, oldTotalCollateralShare, skim);\r\n        emit LogAddCollateral(skim ? address(bentoBox) : msg.sender, to, share);\r\n    }\r\n\r\n    /// @dev Concrete implementation of `removeCollateral`.\r\n    function _removeCollateral(address to, uint256 share) internal {\r\n        userCollateralShare[msg.sender] = userCollateralShare[msg.sender].sub(share);\r\n        totalCollateralShare = totalCollateralShare.sub(share);\r\n        emit LogRemoveCollateral(msg.sender, to, share);\r\n        bentoBox.transfer(collateral, address(this), to, share);\r\n    }\r\n\r\n    /// @notice Removes `share` amount of collateral and transfers it to `to`.\r\n    /// @param to The receiver of the shares.\r\n    /// @param share Amount of shares to remove.\r\n    function removeCollateral(address to, uint256 share) public solvent {\r\n        // accrue must be called because we check solvency\r\n        accrue();\r\n        _removeCollateral(to, share);\r\n    }\r\n\r\n    /// @dev Concrete implementation of `borrow`.\r\n    function _borrow(address to, uint256 amount) internal returns (uint256 part, uint256 share) {\r\n        uint256 feeAmount = amount.mul(BORROW_OPENING_FEE) / BORROW_OPENING_FEE_PRECISION; // A flat % fee is charged for any borrow\r\n        (totalBorrow, part) = totalBorrow.add(amount.add(feeAmount), true);\r\n        accrueInfo.feesEarned = accrueInfo.feesEarned.add(uint128(feeAmount));\r\n        userBorrowPart[msg.sender] = userBorrowPart[msg.sender].add(part);\r\n\r\n        // As long as there are tokens on this contract you can 'mint'... this enables limiting borrows\r\n        share = bentoBox.toShare(magicInternetMoney, amount, false);\r\n        bentoBox.transfer(magicInternetMoney, address(this), to, share);\r\n\r\n        emit LogBorrow(msg.sender, to, amount.add(feeAmount), part);\r\n    }\r\n\r\n    /// @notice Sender borrows `amount` and transfers it to `to`.\r\n    /// @return part Total part of the debt held by borrowers.\r\n    /// @return share Total amount in shares borrowed.\r\n    function borrow(address to, uint256 amount) public solvent returns (uint256 part, uint256 share) {\r\n        accrue();\r\n        (part, share) = _borrow(to, amount);\r\n    }\r\n\r\n    /// @dev Concrete implementation of `repay`.\r\n    function _repay(\r\n        address to,\r\n        bool skim,\r\n        uint256 part\r\n    ) internal returns (uint256 amount) {\r\n        (totalBorrow, amount) = totalBorrow.sub(part, true);\r\n        userBorrowPart[to] = userBorrowPart[to].sub(part);\r\n\r\n        uint256 share = bentoBox.toShare(magicInternetMoney, amount, true);\r\n        bentoBox.transfer(magicInternetMoney, skim ? address(bentoBox) : msg.sender, address(this), share);\r\n        emit LogRepay(skim ? address(bentoBox) : msg.sender, to, amount, part);\r\n    }\r\n\r\n    /// @notice Repays a loan.\r\n    /// @param to Address of the user this payment should go.\r\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\r\n    /// False if tokens from msg.sender in `bentoBox` should be transferred.\r\n    /// @param part The amount to repay. See `userBorrowPart`.\r\n    /// @return amount The total amount repayed.\r\n    function repay(\r\n        address to,\r\n        bool skim,\r\n        uint256 part\r\n    ) public returns (uint256 amount) {\r\n        accrue();\r\n        amount = _repay(to, skim, part);\r\n    }\r\n\r\n    // Functions that need accrue to be called\r\n    uint8 internal constant ACTION_REPAY = 2;\r\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\r\n    uint8 internal constant ACTION_BORROW = 5;\r\n    uint8 internal constant ACTION_GET_REPAY_SHARE = 6;\r\n    uint8 internal constant ACTION_GET_REPAY_PART = 7;\r\n    uint8 internal constant ACTION_ACCRUE = 8;\r\n\r\n    // Functions that don't need accrue to be called\r\n    uint8 internal constant ACTION_ADD_COLLATERAL = 10;\r\n    uint8 internal constant ACTION_UPDATE_EXCHANGE_RATE = 11;\r\n\r\n    // Function on BentoBox\r\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\r\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\r\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\r\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\r\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\r\n\r\n    // Any external call (except to BentoBox)\r\n    uint8 internal constant ACTION_CALL = 30;\r\n\r\n    int256 internal constant USE_VALUE1 = -1;\r\n    int256 internal constant USE_VALUE2 = -2;\r\n\r\n    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.\r\n    function _num(\r\n        int256 inNum,\r\n        uint256 value1,\r\n        uint256 value2\r\n    ) internal pure returns (uint256 outNum) {\r\n        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\r\n    }\r\n\r\n    /// @dev Helper function for depositing into `bentoBox`.\r\n    function _bentoDeposit(\r\n        bytes memory data,\r\n        uint256 value,\r\n        uint256 value1,\r\n        uint256 value2\r\n    ) internal returns (uint256, uint256) {\r\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\r\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\r\n        share = int256(_num(share, value1, value2));\r\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\r\n    }\r\n\r\n    /// @dev Helper function to withdraw from the `bentoBox`.\r\n    function _bentoWithdraw(\r\n        bytes memory data,\r\n        uint256 value1,\r\n        uint256 value2\r\n    ) internal returns (uint256, uint256) {\r\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\r\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\r\n    }\r\n\r\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\r\n    /// Calls to `bentoBox` are not allowed for obvious security reasons.\r\n    /// This also means that calls made from this contract shall *not* be trusted.\r\n    function _call(\r\n        uint256 value,\r\n        bytes memory data,\r\n        uint256 value1,\r\n        uint256 value2\r\n    ) internal returns (bytes memory, uint8) {\r\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) =\r\n            abi.decode(data, (address, bytes, bool, bool, uint8));\r\n\r\n        if (useValue1 && !useValue2) {\r\n            callData = abi.encodePacked(callData, value1);\r\n        } else if (!useValue1 && useValue2) {\r\n            callData = abi.encodePacked(callData, value2);\r\n        } else if (useValue1 && useValue2) {\r\n            callData = abi.encodePacked(callData, value1, value2);\r\n        }\r\n\r\n        require(callee != address(bentoBox) && callee != address(this), \"Cauldron: can't call\");\r\n\r\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\r\n        require(success, \"Cauldron: call failed\");\r\n        return (returnData, returnValues);\r\n    }\r\n\r\n    struct CookStatus {\r\n        bool needsSolvencyCheck;\r\n        bool hasAccrued;\r\n    }\r\n\r\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\r\n    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).\r\n    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.\r\n    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.\r\n    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.\r\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\r\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\r\n    function cook(\r\n        uint8[] calldata actions,\r\n        uint256[] calldata values,\r\n        bytes[] calldata datas\r\n    ) external payable returns (uint256 value1, uint256 value2) {\r\n        CookStatus memory status;\r\n        for (uint256 i = 0; i < actions.length; i++) {\r\n            uint8 action = actions[i];\r\n            if (!status.hasAccrued && action < 10) {\r\n                accrue();\r\n                status.hasAccrued = true;\r\n            }\r\n            if (action == ACTION_ADD_COLLATERAL) {\r\n                (int256 share, address to, bool skim) = abi.decode(datas[i], (int256, address, bool));\r\n                addCollateral(to, skim, _num(share, value1, value2));\r\n            } else if (action == ACTION_REPAY) {\r\n                (int256 part, address to, bool skim) = abi.decode(datas[i], (int256, address, bool));\r\n                _repay(to, skim, _num(part, value1, value2));\r\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\r\n                (int256 share, address to) = abi.decode(datas[i], (int256, address));\r\n                _removeCollateral(to, _num(share, value1, value2));\r\n                status.needsSolvencyCheck = true;\r\n            } else if (action == ACTION_BORROW) {\r\n                (int256 amount, address to) = abi.decode(datas[i], (int256, address));\r\n                (value1, value2) = _borrow(to, _num(amount, value1, value2));\r\n                status.needsSolvencyCheck = true;\r\n            } else if (action == ACTION_UPDATE_EXCHANGE_RATE) {\r\n                (bool must_update, uint256 minRate, uint256 maxRate) = abi.decode(datas[i], (bool, uint256, uint256));\r\n                (bool updated, uint256 rate) = updateExchangeRate();\r\n                require((!must_update || updated) && rate > minRate && (maxRate == 0 || rate > maxRate), \"Cauldron: rate not ok\");\r\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\r\n                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) =\r\n                    abi.decode(datas[i], (address, address, bool, uint8, bytes32, bytes32));\r\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\r\n            } else if (action == ACTION_BENTO_DEPOSIT) {\r\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\r\n            } else if (action == ACTION_BENTO_WITHDRAW) {\r\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\r\n            } else if (action == ACTION_BENTO_TRANSFER) {\r\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\r\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\r\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\r\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\r\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\r\n            } else if (action == ACTION_CALL) {\r\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\r\n\r\n                if (returnValues == 1) {\r\n                    (value1) = abi.decode(returnData, (uint256));\r\n                } else if (returnValues == 2) {\r\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\r\n                }\r\n            } else if (action == ACTION_GET_REPAY_SHARE) {\r\n                int256 part = abi.decode(datas[i], (int256));\r\n                value1 = bentoBox.toShare(magicInternetMoney, totalBorrow.toElastic(_num(part, value1, value2), true), true);\r\n            } else if (action == ACTION_GET_REPAY_PART) {\r\n                int256 amount = abi.decode(datas[i], (int256));\r\n                value1 = totalBorrow.toBase(_num(amount, value1, value2), false);\r\n            }\r\n        }\r\n\r\n        if (status.needsSolvencyCheck) {\r\n            require(_isSolvent(msg.sender, exchangeRate), \"Cauldron: user insolvent\");\r\n        }\r\n    }\r\n\r\n    /// @notice Handles the liquidation of users' balances, once the users' amount of collateral is too low.\r\n    /// @param users An array of user addresses.\r\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.\r\n    /// @param to Address of the receiver in open liquidations if `swapper` is zero.\r\n    function liquidate(\r\n        address[] calldata users,\r\n        uint256[] calldata maxBorrowParts,\r\n        address to,\r\n        ISwapper swapper\r\n    ) public {\r\n        // Oracle can fail but we still need to allow liquidations\r\n        (, uint256 _exchangeRate) = updateExchangeRate();\r\n        accrue();\r\n\r\n        uint256 allCollateralShare;\r\n        uint256 allBorrowAmount;\r\n        uint256 allBorrowPart;\r\n        Rebase memory _totalBorrow = totalBorrow;\r\n        Rebase memory bentoBoxTotals = bentoBox.totals(collateral);\r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            address user = users[i];\r\n            if (!_isSolvent(user, _exchangeRate)) {\r\n                uint256 borrowPart;\r\n                {\r\n                    uint256 availableBorrowPart = userBorrowPart[user];\r\n                    borrowPart = maxBorrowParts[i] > availableBorrowPart ? availableBorrowPart : maxBorrowParts[i];\r\n                    userBorrowPart[user] = availableBorrowPart.sub(borrowPart);\r\n                }\r\n                uint256 borrowAmount = _totalBorrow.toElastic(borrowPart, false);\r\n                uint256 collateralShare =\r\n                    bentoBoxTotals.toBase(\r\n                        borrowAmount.mul(LIQUIDATION_MULTIPLIER).mul(_exchangeRate) /\r\n                            (LIQUIDATION_MULTIPLIER_PRECISION * EXCHANGE_RATE_PRECISION),\r\n                        false\r\n                    );\r\n\r\n                userCollateralShare[user] = userCollateralShare[user].sub(collateralShare);\r\n                emit LogRemoveCollateral(user, to, collateralShare);\r\n                emit LogRepay(msg.sender, user, borrowAmount, borrowPart);\r\n\r\n                // Keep totals\r\n                allCollateralShare = allCollateralShare.add(collateralShare);\r\n                allBorrowAmount = allBorrowAmount.add(borrowAmount);\r\n                allBorrowPart = allBorrowPart.add(borrowPart);\r\n            }\r\n        }\r\n        require(allBorrowAmount != 0, \"Cauldron: all are solvent\");\r\n        _totalBorrow.elastic = _totalBorrow.elastic.sub(allBorrowAmount.to128());\r\n        _totalBorrow.base = _totalBorrow.base.sub(allBorrowPart.to128());\r\n        totalBorrow = _totalBorrow;\r\n        totalCollateralShare = totalCollateralShare.sub(allCollateralShare);\r\n\r\n        // Apply a percentual fee share to sSpell holders\r\n        \r\n        {\r\n            uint256 distributionAmount = (allBorrowAmount.mul(LIQUIDATION_MULTIPLIER) / LIQUIDATION_MULTIPLIER_PRECISION).sub(allBorrowAmount).mul(DISTRIBUTION_PART) / DISTRIBUTION_PRECISION; // Distribution Amount\r\n            allBorrowAmount = allBorrowAmount.add(distributionAmount);\r\n            accrueInfo.feesEarned = accrueInfo.feesEarned.add(distributionAmount.to128());\r\n        }\r\n\r\n        uint256 allBorrowShare = bentoBox.toShare(magicInternetMoney, allBorrowAmount, true);\r\n\r\n        // Swap using a swapper freely chosen by the caller\r\n        // Open (flash) liquidation: get proceeds first and provide the borrow after\r\n        bentoBox.transfer(collateral, address(this), to, allCollateralShare);\r\n        if (swapper != ISwapper(0)) {\r\n            swapper.swap(collateral, magicInternetMoney, msg.sender, allBorrowShare, allCollateralShare);\r\n        }\r\n\r\n        bentoBox.transfer(magicInternetMoney, msg.sender, address(this), allBorrowShare);\r\n    }\r\n\r\n    /// @notice Withdraws the fees accumulated.\r\n    function withdrawFees() public {\r\n        accrue();\r\n        address _feeTo = masterContract.feeTo();\r\n        uint256 _feesEarned = accrueInfo.feesEarned;\r\n        uint256 share = bentoBox.toShare(magicInternetMoney, _feesEarned, false);\r\n        bentoBox.transfer(magicInternetMoney, address(this), _feeTo, share);\r\n        accrueInfo.feesEarned = 0;\r\n\r\n        emit LogWithdrawFees(_feeTo, _feesEarned);\r\n    }\r\n\r\n    /// @notice Sets the beneficiary of interest accrued.\r\n    /// MasterContract Only Admin function.\r\n    /// @param newFeeTo The address of the receiver.\r\n    function setFeeTo(address newFeeTo) public onlyOwner {\r\n        feeTo = newFeeTo;\r\n        emit LogFeeTo(newFeeTo);\r\n    }\r\n\r\n    /// @notice reduces the supply of MIM\r\n    /// @param amount amount to reduce supply by\r\n    function reduceSupply(uint256 amount) public {\r\n        require(msg.sender == masterContract.owner(), \"Caller is not the owner\");\r\n        bentoBox.withdraw(magicInternetMoney, address(this), masterContract.owner(), amount, 0);\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}