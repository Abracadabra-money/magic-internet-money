{
  "language": "Solidity",
  "sources": {
    "contracts/oracles/YVMim3CrvOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IYearnVault {\n    function pricePerShare() external view returns (uint256 price);\n}\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256 price);\n}\n\ncontract YVMIM3CRVOracle is IOracle {\n    ICurvePool public constant MIM3CRV = ICurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    IYearnVault public constant YVMIM3CRV = IYearnVault(0x2DfB14E32e2F8156ec15a2c21c3A6c053af52Be8);\n    IAggregator public constant MIM = IAggregator(0x7A364e8770418566e3eb2001A96116E6138Eb32F);\n    IAggregator constant public DAI = IAggregator(0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9);\n    IAggregator constant public USDC = IAggregator(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6);\n    IAggregator constant public USDT = IAggregator(0x3E7d1eAB13ad0104d2750B8863b489D65364e32D);\n    \n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    // FROM: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6d97f0919547df11be9443b54af2d90631eaa733/contracts/utils/math/Math.sol\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n        uint256 minStable = min(\n            uint256(DAI.latestAnswer()),\n            min(uint256(USDC.latestAnswer()), min(uint256(USDT.latestAnswer()), uint256(MIM.latestAnswer())))\n        );\n\n        uint256 yVCurvePrice = MIM3CRV.get_virtual_price() * minStable * YVMIM3CRV.pricePerShare();\n\n        return 1e62 / yVCurvePrice;\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Chainlink MIM3CRV\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/MIM3CRV\";\n    }\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\ninterface IOracle {\n    /// @notice Get the latest exchange rate.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function get(bytes calldata data) external returns (bool success, uint256 rate);\n\n    /// @notice Check the last exchange rate without any state changes.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peek(bytes calldata data) external view returns (bool success, uint256 rate);\n\n    /// @notice Check the current spot exchange rate without any state changes. For oracles like TWAP this will be different from peek().\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peekSpot(bytes calldata data) external view returns (uint256 rate);\n\n    /// @notice Returns a human readable (short) name about this oracle.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return (string) A human readable symbol name about this oracle.\n    function symbol(bytes calldata data) external view returns (string memory);\n\n    /// @notice Returns a human readable name about this oracle.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return (string) A human readable name about this oracle.\n    function name(bytes calldata data) external view returns (string memory);\n}\n"
    },
    "contracts/oracles/YVIronBankOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IYearnVault {\n    function pricePerShare() external view returns (uint256 price);\n}\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256 price);\n}\n\ncontract YVIronBankOracle is IOracle {\n    ICurvePool public constant IronBank = ICurvePool(0x2dded6Da1BF5DBdF597C45fcFaa3194e53EcfeAF);\n    IYearnVault public constant YVIB = IYearnVault(0x27b7b1ad7288079A66d12350c828D3C00A6F07d7);\n    IAggregator public constant DAI = IAggregator(0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9);\n    IAggregator public constant USDC = IAggregator(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6);\n    IAggregator public constant USDT = IAggregator(0x3E7d1eAB13ad0104d2750B8863b489D65364e32D);\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    // FROM: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6d97f0919547df11be9443b54af2d90631eaa733/contracts/utils/math/Math.sol\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n        // As the price should never be negative, the unchecked conversion is acceptable\n        uint256 minStable = min(uint256(DAI.latestAnswer()), min(uint256(USDC.latestAnswer()), uint256(USDT.latestAnswer())));\n\n        uint256 yVCurvePrice = IronBank.get_virtual_price() * minStable * YVIB.pricePerShare();\n\n        return 1e62 / yVCurvePrice;\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Yearn Chainlink Curve IronBank\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/yvIB\";\n    }\n}\n"
    },
    "contracts/oracles/YVDAIOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n\npragma solidity 0.8.4;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IYearnVault {\n    function pricePerShare() external view returns (uint256 price);\n}\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256 price);\n    function lp_price() external view returns (uint256 price);\n}\n\ncontract YVDAIOracle is IOracle {\n    IYearnVault public constant YVDAI = IYearnVault(0xdA816459F1AB5631232FE5e97a05BBBb94970c95);\n\n    function _get() internal view returns (uint256) {\n        return 1e36 / YVDAI.pricePerShare();\n    }\n\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Chainlink YVDAI\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/YVDAI\";\n    }\n}\n"
    },
    "contracts/oracles/YVCVXETHOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IYearnVault {\n    function pricePerShare() external view returns (uint256 price);\n}\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256 price);\n    function lp_price() external view returns (uint256 price);\n}\n\ncontract YVCVXETHOracle is IOracle {\n    ICurvePool public constant CVXETH = ICurvePool(0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4);\n    IYearnVault public constant YVCVXETH = IYearnVault(0x1635b506a88fBF428465Ad65d00e8d6B6E5846C3);\n    IAggregator public constant ETH = IAggregator(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n        uint256 yVCurvePrice = CVXETH.lp_price() * uint256(ETH.latestAnswer()) * YVCVXETH.pricePerShare();\n\n        return 1e62 / yVCurvePrice;\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Chainlink CVXETH\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/CVXETH\";\n    }\n}\n"
    },
    "contracts/oracles/YVCrvStETHOracle2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IYearnVault {\n    function pricePerShare() external view returns (uint256 price);\n}\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256 price);\n}\n\ncontract YVCrvStETHOracle2 is IOracle {\n    ICurvePool public constant crvSTETH = ICurvePool(0x828b154032950C8ff7CF8085D841723Db2696056);\n    IYearnVault public constant YVSTETH = IYearnVault(0x5faF6a2D186448Dfa667c51CB3D695c7A6E52d8E);\n    IAggregator public constant ETH = IAggregator(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n    IAggregator public constant STETH = IAggregator(0x86392dC19c0b719886221c78AB11eb8Cf5c52812);\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    // FROM: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6d97f0919547df11be9443b54af2d90631eaa733/contracts/utils/math/Math.sol\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n        uint256 yVCurvePrice = crvSTETH.get_virtual_price() * min(uint256(ETH.latestAnswer()), uint256(STETH.latestAnswer())) * YVSTETH.pricePerShare();\n\n        return 1e62 / yVCurvePrice;\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Yearn Chainlink Curve STETH c\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/yvCRVSTETHc\";\n    }\n}\n"
    },
    "contracts/oracles/YVCrvStETHOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IYearnVault {\n    function pricePerShare() external view returns (uint256 price);\n}\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256 price);\n}\n\ncontract YVCrvStETHOracle is IOracle {\n    ICurvePool public constant STETH = ICurvePool(0xDC24316b9AE028F1497c275EB9192a3Ea0f67022);\n    IYearnVault public constant YVSTETH = IYearnVault(0xdCD90C7f6324cfa40d7169ef80b12031770B4325);\n    IAggregator public constant ETH = IAggregator(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    // FROM: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6d97f0919547df11be9443b54af2d90631eaa733/contracts/utils/math/Math.sol\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n        uint256 yVCurvePrice = STETH.get_virtual_price() * uint256(ETH.latestAnswer()) * YVSTETH.pricePerShare();\n\n        return 1e62 / yVCurvePrice;\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Yearn Chainlink Curve STETH\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/yvCRVSTETH\";\n    }\n}\n"
    },
    "contracts/oracles/YearnChainlinkOracleV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IYearnVault {\n    function pricePerShare() external view returns (uint256 price);\n}\n\ncontract YearnChainlinkOracleV3 is IOracle {\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get(\n        address multiply,\n        address divide,\n        uint256 decimals,\n        address yearnVault\n    ) internal view returns (uint256) {\n        uint256 price = uint256(1e36);\n        if (multiply != address(0)) {\n            price = price * uint256(IAggregator(multiply).latestAnswer());\n        } else {\n            price = price * 1e18;\n        }\n\n        if (divide != address(0)) {\n            price = price / uint256(IAggregator(divide).latestAnswer());\n        }\n\n        // @note decimals have to take into account the decimals of the vault asset\n        return price / (decimals * IYearnVault(yearnVault).pricePerShare());\n    }\n\n    function getDataParameter(\n        address multiply,\n        address divide,\n        uint256 decimals,\n        address yearnVault\n    ) public pure returns (bytes memory) {\n        return abi.encode(multiply, divide, decimals, yearnVault);\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata data) public view override returns (bool, uint256) {\n        (address multiply, address divide, uint256 decimals, address yearnVault) = abi.decode(data, (address, address, uint256, address));\n        return (true, _get(multiply, divide, decimals, yearnVault));\n    }\n    \n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata data) public view override returns (bool, uint256) {\n        (address multiply, address divide, uint256 decimals, address yearnVault) = abi.decode(data, (address, address, uint256, address));\n        return (true, _get(multiply, divide, decimals, yearnVault));\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return \"Chainlink\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return \"LINK\";\n    }\n}\n"
    },
    "contracts/swappers/Liquidations/YVMIM3CRVSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/IBentoBoxV1.sol\";\nimport \"../../interfaces/curve/ICurvePool.sol\";\nimport \"../../interfaces/yearn/IYearnVault.sol\";\nimport \"../../interfaces/ISwapperGeneric.sol\";\n\ncontract YVMIM3CRVSwapper is ISwapperGeneric {\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\n    CurvePool public constant MIM3CRV = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    IYearnVault public constant YVMIM3CRV = IYearnVault(0x2DfB14E32e2F8156ec15a2c21c3A6c053af52Be8);\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n\n    constructor() {}\n\n    /// @inheritdoc ISwapperGeneric\n    function swap(\n        IERC20,\n        IERC20,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n        DEGENBOX.withdraw(IERC20(address(YVMIM3CRV)), address(this), address(this), 0, shareFrom);\n\n        // Yearn YVMIM3CRV -> Curve MIM3CRV\n        uint256 mim3CrvAmount = YVMIM3CRV.withdraw();\n\n        // Curve MIM3CRV -> MIM\n        uint256 mimAmount = MIM3CRV.remove_liquidity_one_coin(mim3CrvAmount, 0, 0, address(DEGENBOX));\n\n        (, shareReturned) = DEGENBOX.deposit(MIM, address(DEGENBOX), recipient, mimAmount, 0);\n        extraShare = shareReturned - shareToMin;\n    }\n\n    /// @inheritdoc ISwapperGeneric\n    function swapExact(\n        IERC20,\n        IERC20,\n        address,\n        address,\n        uint256,\n        uint256\n    ) public pure override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0, 0);\n    }\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    },
    "contracts/interfaces/IBentoBoxV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\nimport \"./IERC20.sol\";\n\ninterface IBentoBoxV1 {\n    function toAmount(\n        address _token,\n        uint256 _share,\n        bool _roundUp\n    ) external view returns (uint256);\n\n    function withdraw(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n\n    function deposit(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n\n    function deploy(\n        address masterContract,\n        bytes calldata data,\n        bool useCreate2\n    ) external payable returns (address cloneAddress);\n\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function balanceOf(IERC20, address) external view returns (uint256);\n\n    function totals(IERC20) external view returns (uint128 elastic, uint128 base);\n\n    function flashLoan(\n        address borrower,\n        address receiver,\n        IERC20 token,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n}\n"
    },
    "contracts/interfaces/curve/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase, var-name-mixedcase\npragma solidity >=0.6.12;\n\ninterface CurvePool {\n    function coins(uint256 i) external view returns (address);\n\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy,\n        address receiver\n    ) external returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy,\n        address receiver\n    ) external returns (uint256);\n\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n\n    function get_dy_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function add_liquidity(uint256[2] memory amounts, uint256 _min_mint_amount) external;\n\n    function add_liquidity(uint256[3] memory amounts, uint256 _min_mint_amount) external;\n\n    function add_liquidity(uint256[4] memory amounts, uint256 _min_mint_amount) external;\n\n    function remove_liquidity_one_coin(\n        uint256 tokenAmount,\n        int128 i,\n        uint256 min_amount\n    ) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 tokenAmount,\n        uint256 i,\n        uint256 min_amount\n    ) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 tokenAmount,\n        int128 i,\n        uint256 min_amount,\n        address receiver\n    ) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/yearn/IYearnVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\ninterface IYearnVault {\n    function withdraw() external returns (uint256);\n    function deposit(uint256 amount, address recipient) external returns (uint256);\n}"
    },
    "contracts/interfaces/ISwapperGeneric.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.6.12;\n\nimport \"./IERC20.sol\";\n\ninterface ISwapperGeneric {\n    /// @notice Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\n    /// Swaps it for at least 'amountToMin' of token 'to'.\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\n    /// Returns the amount of tokens 'to' transferred to BentoBox.\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) external returns (uint256 extraShare, uint256 shareReturned);\n\n    /// @notice Calculates the amount of token 'from' needed to complete the swap (amountFrom),\n    /// this should be less than or equal to amountFromMax.\n    /// Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\n    /// Swaps it for exactly 'exactAmountTo' of token 'to'.\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\n    /// Transfers allocated, but unused 'from' tokens within the BentoBox to 'refundTo' (amountFromMax - amountFrom).\n    /// Returns the amount of 'from' tokens withdrawn from BentoBox (amountFrom).\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) external returns (uint256 shareUsed, uint256 shareReturned);\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/swappers/Liquidations/YVCVXETHSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/IBentoBoxV1.sol\";\nimport \"../../interfaces/curve/ICurvePool.sol\";\nimport \"../../interfaces/curve/ICurveThreeCryptoPool.sol\";\nimport \"../../interfaces/yearn/IYearnVault.sol\";\nimport \"../../interfaces/Tether.sol\";\nimport \"../../interfaces/ISwapperGeneric.sol\";\n\ncontract YVCVXETHSwapper is ISwapperGeneric {\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    CurvePool public constant CVXETHPOOL = CurvePool(0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4);\n    IYearnVault public constant YVCVXETH = IYearnVault(0x1635b506a88fBF428465Ad65d00e8d6B6E5846C3);\n    Tether public constant USDT = Tether(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    IERC20 public constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    CurveThreeCryptoPool public constant THREECRYPTO = CurveThreeCryptoPool(0xD51a44d3FaE010294C616388b506AcdA1bfAAE46);\n\n    constructor() {\n        WETH.approve(address(THREECRYPTO), type(uint256).max);\n        USDT.approve(address(MIM3POOL), type(uint256).max);\n    }\n\n    /// @inheritdoc ISwapperGeneric\n    function swap(\n        IERC20,\n        IERC20,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n        DEGENBOX.withdraw(IERC20(address(YVCVXETH)), address(this), address(this), 0, shareFrom);\n\n        // Yearn CVXETH -> Curve CVXETH\n        uint256 cvxEthAmount = YVCVXETH.withdraw();\n\n        // Curve CVXETH -> WETH\n        uint256 wethAmount = CVXETHPOOL.remove_liquidity_one_coin(cvxEthAmount, uint256(0), 0);\n\n        // WETH -> USDT\n        THREECRYPTO.exchange(2, 0, wethAmount, 0);\n\n        // USDT -> MIM\n        uint256 mimAmount = MIM3POOL.exchange_underlying(3, 0, USDT.balanceOf(address(this)), 0, address(DEGENBOX));\n\n        (, shareReturned) = DEGENBOX.deposit(MIM, address(DEGENBOX), recipient, mimAmount, 0);\n        extraShare = shareReturned - shareToMin;\n    }\n\n    /// @inheritdoc ISwapperGeneric\n    function swapExact(\n        IERC20,\n        IERC20,\n        address,\n        address,\n        uint256,\n        uint256\n    ) public pure override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0, 0);\n    }\n}\n"
    },
    "contracts/interfaces/curve/ICurveThreeCryptoPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\ninterface CurveThreeCryptoPool {\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy\n    ) payable external;\n\n    function get_dy(\n        uint256 i,\n        uint256 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function add_liquidity(uint256[3] memory amounts, uint256 _min_mint_amount) external;\n}\n"
    },
    "contracts/interfaces/Tether.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\ninterface Tether {\n    function approve(address spender, uint256 value) external;\n\n    function balanceOf(address user) external view returns (uint256);\n\n    function transfer(address to, uint256 value) external;\n}\n"
    },
    "contracts/swappers/Leverage/YVCVXETHLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/IBentoBoxV1.sol\";\nimport \"../../interfaces/curve/ICurvePool.sol\";\nimport \"../../interfaces/curve/ICurveThreeCryptoPool.sol\";\nimport \"../../interfaces/yearn/IYearnVault.sol\";\nimport \"../../interfaces/Tether.sol\";\nimport \"../../interfaces/ILevSwapperGeneric.sol\";\n\ncontract YVCVXETHLevSwapper is ILevSwapperGeneric {\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    CurvePool public constant CVXETHPOOL = CurvePool(0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4);\n    IYearnVault public constant YVCVXETH = IYearnVault(0x1635b506a88fBF428465Ad65d00e8d6B6E5846C3);\n    Tether public constant USDT = Tether(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    IERC20 public constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 public constant CVXETH = IERC20(0x3A283D9c08E8b55966afb64C515f5143cf907611);\n    CurveThreeCryptoPool public constant THREECRYPTO = CurveThreeCryptoPool(0xD51a44d3FaE010294C616388b506AcdA1bfAAE46);\n\n    constructor() {\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n        USDT.approve(address(THREECRYPTO), type(uint256).max);\n        WETH.approve(address(CVXETHPOOL), type(uint256).max);\n        CVXETH.approve(address(YVCVXETH), type(uint256).max);\n    }\n\n    /// @inheritdoc ILevSwapperGeneric\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n        (uint256 mimAmount, ) = DEGENBOX.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        // MIM -> USDT\n        uint256 usdtAmount = MIM3POOL.exchange_underlying(0, 3, mimAmount, 0, address(this));\n\n        // USDT -> WETH\n        THREECRYPTO.exchange(0, 2, usdtAmount, 0);\n\n        // WETH -> Curve CVXETH\n        uint256[2] memory amounts = [WETH.balanceOf(address(this)), 0];\n        CVXETHPOOL.add_liquidity(amounts, 0);\n\n        // Curve CVXETH -> Yearn CVXETH\n        uint256 yvCvxEthAmount = YVCVXETH.deposit(type(uint256).max, address(DEGENBOX));\n\n        (, shareReturned) = DEGENBOX.deposit(IERC20(address(YVCVXETH)), address(DEGENBOX), recipient, yvCvxEthAmount, 0);\n        extraShare = shareReturned - shareToMin;\n    }\n}\n"
    },
    "contracts/interfaces/ILevSwapperGeneric.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\ninterface ILevSwapperGeneric {\n    /// @notice Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) external returns (uint256 extraShare, uint256 shareReturned);\n}\n"
    },
    "contracts/swappers/Leverage/YVMIM3CrvLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/IBentoBoxV1.sol\";\nimport \"../../interfaces/yearn/IYearnVault.sol\";\nimport \"../../interfaces/ILevSwapperGeneric.sol\";\n\ninterface CurvePool {\n    function add_liquidity(\n        address pool,\n        uint256[4] memory amounts,\n        uint256 _min_mint_amount\n    ) external returns (uint256);\n}\n\ncontract YVMIM3CRVLevSwapper is ILevSwapperGeneric {\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\n    CurvePool public constant THREEPOOL = CurvePool(0xA79828DF1850E8a3A3064576f380D90aECDD3359);\n    IERC20 public constant MIM3CRV = IERC20(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    IYearnVault public constant YVMIM3CRV = IYearnVault(0x2DfB14E32e2F8156ec15a2c21c3A6c053af52Be8);\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n\n    constructor() {\n        MIM.approve(address(THREEPOOL), type(uint256).max);\n        MIM3CRV.approve(address(YVMIM3CRV), type(uint256).max);\n    }\n\n    /// @inheritdoc ILevSwapperGeneric\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n        (uint256 mimAmount, ) = DEGENBOX.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        // MIM -> MIM3CRV\n        // MIM, DAI, USDC, USDT\n        uint256[4] memory amounts = [mimAmount, 0, 0, 0];\n        uint256 mim3CrvAmount = THREEPOOL.add_liquidity(address(MIM3CRV), amounts, 0);\n\n        // MIM3CRV -> YVMIM3CRV\n        uint256 yvMim3CrvAmount = YVMIM3CRV.deposit(mim3CrvAmount, address(DEGENBOX));\n\n        (, shareReturned) = DEGENBOX.deposit(IERC20(address(YVMIM3CRV)), address(DEGENBOX), recipient, yvMim3CrvAmount, 0);\n        extraShare = shareReturned - shareToMin;\n    }\n}\n"
    },
    "contracts/swappers/Leverage/YVDAILevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"../../interfaces/IBentoBoxV1.sol\";\nimport \"../../interfaces/curve/ICurvePool.sol\";\nimport \"../../interfaces/yearn/IYearnVault.sol\";\nimport \"../../interfaces/ILevSwapperGeneric.sol\";\n\ncontract YVDAILevSwapper is ILevSwapperGeneric {\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    IERC20 public constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    IYearnVault public constant DAI_VAULT = IYearnVault(0xdA816459F1AB5631232FE5e97a05BBBb94970c95);\n\n    constructor() {\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n        DAI.approve(address(DAI_VAULT), type(uint256).max);\n    }\n\n    /// @inheritdoc ILevSwapperGeneric\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n        (uint256 amount, ) = DEGENBOX.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        // MIM -> DAI\n        amount = MIM3POOL.exchange_underlying(0, 1, amount, 0, address(this));\n\n        // DAI -> DAI_VAULT\n        amount = DAI_VAULT.deposit(amount, address(DEGENBOX));\n\n        (, shareReturned) = DEGENBOX.deposit(IERC20(address(DAI_VAULT)), address(DEGENBOX), recipient, amount, 0);\n        extraShare = shareReturned - shareToMin;\n    }\n}\n"
    },
    "contracts/swappers/Leverage/MimFtmLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Router01.sol\";\nimport \"../../libraries/Babylonian.sol\";\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IBentoBoxV1 {\n    function withdraw(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n\n    function deposit(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n}\n\ncontract MimFtmLevSwapper {\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0x74A0BcA2eeEdf8883cb91E37e9ff49430f20a616);\n    IUniswapV2Pair public constant MIMFTM = IUniswapV2Pair(0x6f86e65b255c9111109d2D2325ca2dFc82456efc);\n    IUniswapV2Router01 public constant ROUTER = IUniswapV2Router01(0xF491e7B69E4244ad4002BC14e878a34207E38c29);\n\n    uint256 private constant DEADLINE = 0xf000000000000000000000000000000000000000000000000000000000000000; // ~ placeholder for swap deadline\n\n    IERC20 public constant MIM = IERC20(0x82f0B8B456c1A451378467398982d4834b6829c1);\n    IERC20 public constant WFTM = IERC20(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83);\n\n    constructor() {\n        MIMFTM.approve(address(DEGENBOX), type(uint256).max);\n        MIM.approve(address(ROUTER), type(uint256).max);\n        WFTM.approve(address(ROUTER), type(uint256).max);\n    }\n\n    function _calculateSwapInAmount(uint256 reserveIn, uint256 userIn) internal pure returns (uint256) {\n        return (Babylonian.sqrt(reserveIn * ((userIn * 3988000) + (reserveIn * 3988009))) - (reserveIn * 1997)) / 1994;\n    }\n\n    function _getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n        (uint256 amountFrom, ) = DEGENBOX.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        // Determine optimal amount of AVAX to swap for liquidity providing\n        (uint256 reserve1, uint256 reserve0, ) = MIMFTM.getReserves();\n        uint256 mimSwapInAmount = _calculateSwapInAmount(reserve0, amountFrom);\n        uint256 avaxAmount = _getAmountOut(mimSwapInAmount, reserve0, reserve1);\n        MIM.transfer(address(MIMFTM), mimSwapInAmount);\n        MIMFTM.swap(avaxAmount, 0, address(this), \"\");\n\n        ROUTER.addLiquidity(\n            address(MIM),\n            address(WFTM),\n            MIM.balanceOf(address(this)),\n            WFTM.balanceOf(address(this)),\n            1,\n            1,\n            address(this),\n            DEADLINE\n        );\n\n        (, shareReturned) = DEGENBOX.deposit(IERC20(address(MIMFTM)), address(this), recipient, MIMFTM.balanceOf(address(this)), 0);\n        extraShare = shareReturned - shareToMin;\n    }\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}"
    },
    "contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.4;\n\n/// @notice Babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method).\nlibrary Babylonian {\n    // computes square roots using the babylonian method\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "contracts/swappers/Leverage/MimAvaxLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Router01.sol\";\nimport \"../../libraries/Babylonian.sol\";\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IBentoBoxV1 {\n    function withdraw(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n\n    function deposit(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n}\n\ncontract MimAvaxLevSwapper {\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0x1fC83f75499b7620d53757f0b01E2ae626aAE530);\n    IUniswapV2Pair public constant MIMAVAX = IUniswapV2Pair(0xcBb424fd93cDeC0EF330d8A8C985E8b147F62339);\n    IUniswapV2Router01 public constant ROUTER = IUniswapV2Router01(0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506);\n\n    uint256 private constant DEADLINE = 0xf000000000000000000000000000000000000000000000000000000000000000; // ~ placeholder for swap deadline\n\n    IERC20 public constant MIM = IERC20(0x130966628846BFd36ff31a822705796e8cb8C18D);\n    IERC20 public constant WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n\n    constructor() {\n        MIMAVAX.approve(address(DEGENBOX), type(uint256).max);\n        MIM.approve(address(ROUTER), type(uint256).max);\n        WAVAX.approve(address(ROUTER), type(uint256).max);\n    }\n\n    function _calculateSwapInAmount(uint256 reserveIn, uint256 userIn) internal pure returns (uint256) {\n        return (Babylonian.sqrt(reserveIn * ((userIn * 3988000) + (reserveIn * 3988009))) - (reserveIn * 1997)) / 1994;\n    }\n\n    function _getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n        (uint256 amountFrom, ) = DEGENBOX.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        // Determine optimal amount of AVAX to swap for liquidity providing\n        (uint256 reserve0, uint256 reserve1, ) = MIMAVAX.getReserves();\n        uint256 mimSwapInAmount = _calculateSwapInAmount(reserve0, amountFrom);\n        uint256 avaxAmount = _getAmountOut(mimSwapInAmount, reserve0, reserve1);\n        MIM.transfer(address(MIMAVAX), mimSwapInAmount);\n        MIMAVAX.swap(0, avaxAmount, address(this), \"\");\n\n        ROUTER.addLiquidity(\n            address(MIM),\n            address(WAVAX),\n            MIM.balanceOf(address(this)),\n            WAVAX.balanceOf(address(this)),\n            1,\n            1,\n            address(this),\n            DEADLINE\n        );\n\n        (, shareReturned) = DEGENBOX.deposit(IERC20(address(MIMAVAX)), address(this), recipient, MIMAVAX.balanceOf(address(this)), 0);\n        extraShare = shareReturned - shareToMin;\n    }\n}\n"
    },
    "contracts/swappers/Leverage/AvaxUsdtLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Router01.sol\";\nimport \"../../libraries/Babylonian.sol\";\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IBentoBoxV1 {\n    function withdraw(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n\n    function deposit(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n}\n\ncontract AvaxUsdtLevSwapper {\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0x1fC83f75499b7620d53757f0b01E2ae626aAE530);\n    IUniswapV2Pair public constant AVAXUSDT = IUniswapV2Pair(0xeD8CBD9F0cE3C6986b22002F03c6475CEb7a6256);\n    IUniswapV2Pair public constant MIMAVAX = IUniswapV2Pair(0x781655d802670bbA3c89aeBaaEa59D3182fD755D);\n    IUniswapV2Router01 public constant ROUTER = IUniswapV2Router01(0x60aE616a2155Ee3d9A68541Ba4544862310933d4);\n\n    uint256 private constant DEADLINE = 0xf000000000000000000000000000000000000000000000000000000000000000; // ~ placeholder for swap deadline\n\n    IERC20 public constant MIM = IERC20(0x130966628846BFd36ff31a822705796e8cb8C18D);\n    IERC20 public constant WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n    IERC20 public constant USDT = IERC20(0xc7198437980c041c805A1EDcbA50c1Ce5db95118);\n\n    constructor() {\n        AVAXUSDT.approve(address(DEGENBOX), type(uint256).max);\n        WAVAX.approve(address(ROUTER), type(uint256).max);\n        USDT.approve(address(ROUTER), type(uint256).max);\n    }\n\n    function _calculateSwapInAmount(uint256 reserveIn, uint256 userIn) internal pure returns (uint256) {\n        return (Babylonian.sqrt(reserveIn * ((userIn * 3988000) + (reserveIn * 3988009))) - (reserveIn * 1997)) / 1994;\n    }\n\n    function _getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n        (uint256 amountFrom, ) = DEGENBOX.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        // Swap MIM to AVAX\n        (uint256 reserve0, uint256 reserve1, ) = MIMAVAX.getReserves();\n        uint256 avaxFromMim = _getAmountOut(amountFrom, reserve0, reserve1);\n        MIM.transfer(address(MIMAVAX), amountFrom);\n        MIMAVAX.swap(0, avaxFromMim, address(this), new bytes(0));\n\n        // Determine optimal amount of AVAX to swap for liquidity providing\n        (reserve0, reserve1, ) = AVAXUSDT.getReserves();\n        uint256 avaxSwapInAmount = _calculateSwapInAmount(reserve0, avaxFromMim);\n        uint256 usdtAmount = _getAmountOut(avaxSwapInAmount, reserve0, reserve1);\n        WAVAX.transfer(address(AVAXUSDT), avaxSwapInAmount);\n        AVAXUSDT.swap(0, usdtAmount, address(this), \"\");\n\n        ROUTER.addLiquidity(\n            address(WAVAX),\n            address(USDT),\n            WAVAX.balanceOf(address(this)),\n            USDT.balanceOf(address(this)),\n            1,\n            1,\n            address(this),\n            DEADLINE\n        );\n\n        (, shareReturned) = DEGENBOX.deposit(IERC20(address(AVAXUSDT)), address(this), recipient, AVAXUSDT.balanceOf(address(this)), 0);\n        extraShare = shareReturned - shareToMin;\n    }\n}\n"
    },
    "contracts/swappers/Liquidations/USTSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../../interfaces/ISwapperGeneric.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function add_liquidity(uint256[3] memory amounts, uint256 _min_mint_amount) external;\n}\n\ninterface IBentoBoxV1 {\n    function withdraw(IERC20 token, address from, address to, uint256 amount, uint256 share) external returns(uint256, uint256);\n    function deposit(IERC20 token, address from, address to, uint256 amount, uint256 share) external returns(uint256, uint256);\n}\n\ncontract USTSwapper is ISwapperGeneric {\n\n    // Local variables\n    IBentoBoxV1 public constant degenBox = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\n    CurvePool constant public UST2POOL = CurvePool(0x55A8a39bc9694714E2874c1ce77aa1E599461E18);\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    IERC20 public constant UST = IERC20(0xa47c8bf37f92aBed4A126BDA807A7b7498661acD);\n\n    constructor() public {\n        UST.approve(address(UST2POOL), type(uint256).max);\n        MIM.approve(address(degenBox), type(uint256).max);\n    }\n\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapperGeneric\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = degenBox.withdraw(UST, address(this), address(this), 0, shareFrom);\n\n        uint256 amountTo = UST2POOL.exchange(1, 0, amountFrom, 0, address(degenBox));\n\n        (, shareReturned) = degenBox.deposit(MIM, address(degenBox), recipient, amountTo, 0);\n        extraShare = shareReturned - shareToMin;\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapperGeneric\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0,0);\n    }\n}"
    },
    "contracts/swappers/Liquidations/MimFtmSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/ISwapperGeneric.sol\";\n\ninterface IBentoBoxV1 {\n    function withdraw(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n\n    function deposit(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n}\n\ncontract MimFtmSwapper is ISwapperGeneric {\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0x74A0BcA2eeEdf8883cb91E37e9ff49430f20a616);\n    IUniswapV2Pair public constant MIMFTM = IUniswapV2Pair(0x6f86e65b255c9111109d2D2325ca2dFc82456efc);\n\n    IERC20 public constant MIM = IERC20(0x82f0B8B456c1A451378467398982d4834b6829c1);\n    IERC20 public constant WFTM = IERC20(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83);\n\n    constructor() {\n        MIM.approve(address(DEGENBOX), type(uint256).max);\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function _getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapperGeneric\n    function swap(\n        IERC20,\n        IERC20,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n        (uint256 amountFrom, ) = DEGENBOX.withdraw(IERC20(address(MIMFTM)), address(this), address(this), 0, shareFrom);\n\n        MIMFTM.transfer(address(MIMFTM), amountFrom);\n        (uint256 ftmAmount, uint256 mimAmount) = MIMFTM.burn(address(this));\n\n        // swap AVAX to MIM\n        (uint256 reserve0, uint256 reserve1, ) = MIMFTM.getReserves();\n        uint256 mimFromFtm = _getAmountOut(ftmAmount, reserve0, reserve1);\n        WFTM.transfer(address(MIMFTM), ftmAmount);\n        MIMFTM.swap(0, mimFromFtm, address(this), new bytes(0));\n        mimAmount += mimFromFtm;\n\n        (, shareReturned) = DEGENBOX.deposit(MIM, address(this), recipient, mimAmount, 0);\n        extraShare = shareReturned - shareToMin;\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapperGeneric\n    function swapExact(\n        IERC20,\n        IERC20,\n        address,\n        address,\n        uint256,\n        uint256\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0, 0);\n    }\n}\n"
    },
    "contracts/swappers/Liquidations/MimAvaxSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/ISwapperGeneric.sol\";\n\ninterface IBentoBoxV1 {\n    function withdraw(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n\n    function deposit(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n}\n\ncontract MimAvaxSwapper is ISwapperGeneric {\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0x1fC83f75499b7620d53757f0b01E2ae626aAE530);\n    IUniswapV2Pair public constant MIMAVAX = IUniswapV2Pair(0xcBb424fd93cDeC0EF330d8A8C985E8b147F62339);\n    IERC20 public constant MIM = IERC20(0x130966628846BFd36ff31a822705796e8cb8C18D);\n    IERC20 public constant WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n\n    constructor() {\n        MIM.approve(address(DEGENBOX), type(uint256).max);\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function _getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapperGeneric\n    function swap(\n        IERC20,\n        IERC20,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n        (uint256 amountFrom, ) = DEGENBOX.withdraw(IERC20(address(MIMAVAX)), address(this), address(this), 0, shareFrom);\n\n        MIMAVAX.transfer(address(MIMAVAX), amountFrom);\n        (uint256 mimAmount, uint256 avaxAmount) = MIMAVAX.burn(address(this));\n\n        // swap AVAX to MIM\n        (uint256 reserve0, uint256 reserve1, ) = MIMAVAX.getReserves();\n        uint256 mimFromAvax = _getAmountOut(avaxAmount, reserve1, reserve0);\n        WAVAX.transfer(address(MIMAVAX), avaxAmount);\n        MIMAVAX.swap(mimFromAvax, 0, address(this), new bytes(0));\n        mimAmount += mimFromAvax;\n\n        (, shareReturned) = DEGENBOX.deposit(MIM, address(this), recipient, mimAmount, 0);\n        extraShare = shareReturned - shareToMin;\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapperGeneric\n    function swapExact(\n        IERC20,\n        IERC20,\n        address,\n        address,\n        uint256,\n        uint256\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0, 0);\n    }\n}\n"
    },
    "contracts/swappers/Liquidations/AvaxUsdtSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/ISwapperGeneric.sol\";\n\ninterface IBentoBoxV1 {\n    function withdraw(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n\n    function deposit(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n}\n\ncontract AvaxUsdtSwapper is ISwapperGeneric {\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0x1fC83f75499b7620d53757f0b01E2ae626aAE530);\n    IUniswapV2Pair public constant AVAXUSDT = IUniswapV2Pair(0xeD8CBD9F0cE3C6986b22002F03c6475CEb7a6256);\n    IUniswapV2Pair public constant MIMAVAX = IUniswapV2Pair(0x781655d802670bbA3c89aeBaaEa59D3182fD755D);\n    IERC20 public constant MIM = IERC20(0x130966628846BFd36ff31a822705796e8cb8C18D);\n    IERC20 public constant WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n    IERC20 public constant USDT = IERC20(0xc7198437980c041c805A1EDcbA50c1Ce5db95118);\n\n    constructor() {\n        MIM.approve(address(DEGENBOX), type(uint256).max);\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function _getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapperGeneric\n    function swap(\n        IERC20,\n        IERC20,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n        (uint256 amountFrom, ) = DEGENBOX.withdraw(IERC20(address(AVAXUSDT)), address(this), address(this), 0, shareFrom);\n\n        AVAXUSDT.transfer(address(AVAXUSDT), amountFrom);\n        (uint256 avaxAmount, uint256 usdtAmount) = AVAXUSDT.burn(address(this));\n        \n        // swap USDT to AVAX\n        (uint256 reserve0, uint256 reserve1, ) = AVAXUSDT.getReserves();\n        uint256 avaxFromUsdt = _getAmountOut(usdtAmount, reserve1, reserve0);\n        USDT.transfer(address(AVAXUSDT), usdtAmount);\n        AVAXUSDT.swap(avaxFromUsdt, 0, address(this), new bytes(0));\n        avaxAmount += avaxFromUsdt;\n\n        // swap AVAX to MIM\n        (reserve0, reserve1, ) = MIMAVAX.getReserves();\n        uint256 mimFromAvax = _getAmountOut(avaxAmount, reserve1, reserve0);\n        WAVAX.transfer(address(MIMAVAX), avaxAmount);\n        MIMAVAX.swap(mimFromAvax, 0, address(this), new bytes(0));\n\n        (, shareReturned) = DEGENBOX.deposit(MIM, address(this), recipient, mimFromAvax, 0);\n        extraShare = shareReturned - shareToMin;\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapperGeneric\n    function swapExact(\n        IERC20,\n        IERC20,\n        address,\n        address,\n        uint256,\n        uint256\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0, 0);\n    }\n}\n"
    },
    "contracts/mocks/USTSwapperMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../interfaces/ISwapperGeneric.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function add_liquidity(uint256[3] memory amounts, uint256 _min_mint_amount) external;\n}\n\ninterface IBentoBoxV1 {\n    function withdraw(IERC20 token, address from, address to, uint256 amount, uint256 share) external returns(uint256, uint256);\n    function deposit(IERC20 token, address from, address to, uint256 amount, uint256 share) external returns(uint256, uint256);\n}\n\ncontract USTSwapperMock is ISwapperGeneric {\n\n    // Local variables\n    IBentoBoxV1 public constant degenBox = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\n    CurvePool constant public UST2POOL = CurvePool(0x55A8a39bc9694714E2874c1ce77aa1E599461E18);\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    IERC20 public constant UST = IERC20(0xa47c8bf37f92aBed4A126BDA807A7b7498661acD);\n\n    constructor() public {\n        UST.approve(address(UST2POOL), type(uint256).max);\n        MIM.approve(address(degenBox), type(uint256).max);\n    }\n\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapperGeneric\n    function swap(\n        IERC20,\n        IERC20,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = degenBox.withdraw(UST, address(this), address(this), 0, shareFrom);\n\n        uint256 amountTo = UST2POOL.exchange(1, 0, amountFrom, 0, address(degenBox));\n\n        (, shareReturned) = degenBox.deposit(MIM, address(degenBox), recipient, amountTo, 0);\n        extraShare = shareReturned - shareToMin;\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapperGeneric\n    function swapExact(\n        IERC20,\n        IERC20,\n        address,\n        address,\n        uint256,\n        uint256\n    ) public override pure returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0,0);\n    }\n}"
    },
    "contracts/oracles/WethOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract WethOracle is IOracle {\n    IAggregator public constant ETHUSD = IAggregator(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n        return 1e26 / uint256(ETHUSD.latestAnswer());\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Chainlink ETH\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/ETH\";\n    }\n}\n"
    },
    "contracts/oracles/USTOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ncontract USTOracle is IOracle {\n    IAggregator public constant UST = IAggregator(0x8b6d9085f310396C6E4f0012783E9f850eaa8a82);\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n        uint256 ustPrice = uint256(UST.latestAnswer());\n\n        return 1e26 / ustPrice;\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Chainlink UST\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/UST\";\n    }\n}\n"
    },
    "contracts/oracles/sSpellOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract sSpellOracle is IOracle {\n    IAggregator public constant SPELLUSD = IAggregator(0x8c110B94C5f1d347fAcF5E1E938AB2db60E3c9a8);\n\n    IERC20 public constant SSPELL = IERC20(0x26FA3fFFB6EfE8c1E69103aCb4044C26B9A106a9);\n    IERC20 public constant SPELL = IERC20(0x090185f2135308BaD17527004364eBcC2D37e5F6);\n\n    function toSSpell(uint256 amount) internal view returns (uint256) {\n        return (amount * SPELL.balanceOf(address(SSPELL))) / SSPELL.totalSupply();\n    }\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n        return 1e26 / toSSpell(uint256(SPELLUSD.latestAnswer()));\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Chainlink sSpell\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/sSpell\";\n    }\n}\n"
    },
    "contracts/oracles/SpellOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract SpellOracle is IOracle {\n    IAggregator public constant SPELLUSD = IAggregator(0x8c110B94C5f1d347fAcF5E1E938AB2db60E3c9a8);\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n        return 1e26 / uint256(SPELLUSD.latestAnswer());\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Chainlink Spell\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/Spell\";\n    }\n}\n"
    },
    "contracts/oracles/RenBTCCrvOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256 price);\n}\n\ncontract RenBTCCrvOracle is IOracle {\n    ICurvePool public constant renCrv = ICurvePool(0x93054188d876f558f4a66B2EF1d97d16eDf0895B);\n    IAggregator public constant BTC = IAggregator(0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    // FROM: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6d97f0919547df11be9443b54af2d90631eaa733/contracts/utils/math/Math.sol\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n        // As the price should never be negative, the unchecked conversion is acceptable\n        uint256 renCrvPrice = renCrv.get_virtual_price() * uint256(BTC.latestAnswer());\n\n        return 1e44 / renCrvPrice;\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Chainlink Ren Swap\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/RenCrv\";\n    }\n}\n"
    },
    "contracts/oracles/MagicCRVOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IMagicCRV {\n    function totalSupply() external view returns (uint256);\n\n    function totalCRVTokens() external view returns (uint256);\n}\n\ncontract MagicCRVOracle is IOracle {\n    IAggregator public constant CRV = IAggregator(0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f);\n    IMagicCRV public immutable magicCRV;\n\n    constructor(IMagicCRV _magicCRV) {\n        magicCRV = _magicCRV;\n    }\n\n    function _get() internal view returns (uint256) {\n        uint256 totalSupply = magicCRV.totalSupply();\n\n        if (totalSupply == 0) {\n            return 1e26 / uint256(CRV.latestAnswer());\n        }\n\n        return 1e26 / ((uint256(CRV.latestAnswer()) * magicCRV.totalCRVTokens()) / totalSupply);\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Chainlink MagicCRV\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/MagicCRV\";\n    }\n}\n"
    },
    "contracts/oracles/FTMOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract FTMOracle is IOracle {\n    IAggregator constant public FTMUSD = IAggregator(0xf4766552D15AE4d256Ad41B6cf2933482B0680dc);\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n\n        return 1e26 / uint256(FTMUSD.latestAnswer());\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Chainlink FTM\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/FTM\";\n    }\n}\n"
    },
    "contracts/oracles/Frax3CrvOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IYearnVault {\n    function pricePerShare() external view returns (uint256 price);\n}\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256 price);\n}\n\ncontract Frax3CrvOracle is IOracle {\n    ICurvePool public constant frax3crv = ICurvePool(0xd632f22692FaC7611d2AA1C0D552930D43CAEd3B);\n    IAggregator public constant FRAX = IAggregator(0xB9E1E3A9feFf48998E45Fa90847ed4D467E8BcfD);\n    IAggregator public constant DAI = IAggregator(0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9);\n    IAggregator public constant USDC = IAggregator(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6);\n    IAggregator public constant USDT = IAggregator(0x3E7d1eAB13ad0104d2750B8863b489D65364e32D);\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    // FROM: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6d97f0919547df11be9443b54af2d90631eaa733/contracts/utils/math/Math.sol\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n        // As the price should never be negative, the unchecked conversion is acceptable\n        uint256 minStable = min(\n            uint256(DAI.latestAnswer()),\n            min(uint256(USDC.latestAnswer()), min(uint256(USDT.latestAnswer()), uint256(FRAX.latestAnswer())))\n        );\n\n        uint256 yVCurvePrice = frax3crv.get_virtual_price() * minStable;\n\n        return 1e44 / yVCurvePrice;\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Chainlink Frax3Crv\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/Frax3crv\";\n    }\n}\n"
    },
    "contracts/oracles/CakeOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract CakeOracle is IOracle {\n    IAggregator public constant BNBUSD = IAggregator(0xB6064eD41d4f67e353768aA239cA86f4F73665a1);\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n        return 1e26 / uint256(BNBUSD.latestAnswer());\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Chainlink CAKE\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/CAKE\";\n    }\n}\n"
    },
    "contracts/oracles/BNBOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract BNBOracle is IOracle {\n    IAggregator public constant BNBUSD = IAggregator(0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE);\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n        return 1e26 / uint256(BNBUSD.latestAnswer());\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Chainlink BNB\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/BNB\";\n    }\n}\n"
    },
    "contracts/oracles/3CrvOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IYearnVault {\n    function pricePerShare() external view returns (uint256 price);\n}\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256 price);\n}\n\ncontract ThreeCrvOracle is IOracle {\n    ICurvePool public constant threecrv = ICurvePool(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);\n    IAggregator public constant DAI = IAggregator(0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9);\n    IAggregator public constant USDC = IAggregator(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6);\n    IAggregator public constant USDT = IAggregator(0x3E7d1eAB13ad0104d2750B8863b489D65364e32D);\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    // FROM: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6d97f0919547df11be9443b54af2d90631eaa733/contracts/utils/math/Math.sol\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n        // As the price should never be negative, the unchecked conversion is acceptable\n        uint256 minStable = min(uint256(DAI.latestAnswer()), min(uint256(USDC.latestAnswer()), uint256(USDT.latestAnswer())));\n\n        uint256 yVCurvePrice = threecrv.get_virtual_price() * minStable;\n\n        return 1e44 / yVCurvePrice;\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public pure override returns (string memory) {\n        return \"Chainlink 3Crv\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public pure override returns (string memory) {\n        return \"LINK/3crv\";\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 690
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}