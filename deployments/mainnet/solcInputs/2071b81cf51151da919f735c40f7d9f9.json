{
  "language": "Solidity",
  "sources": {
    "contracts/swappers/Liquidations/YVCVXETHSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\r\nimport \"../../interfaces/IBentoBoxV1.sol\";\r\nimport \"../../interfaces/curve/ICurvePool.sol\";\r\nimport \"../../interfaces/curve/ICurveThreeCryptoPool.sol\";\r\nimport \"../../interfaces/yearn/IYearnVault.sol\";\r\nimport \"../../interfaces/Tether.sol\";\r\nimport \"../../interfaces/ISwapperGeneric.sol\";\r\n\r\ncontract YVCVXETHSwapper is ISwapperGeneric {\r\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\r\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\r\n    CurvePool public constant CVXETHPOOL = CurvePool(0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4);\r\n    IYearnVault public constant YVCVXETH = IYearnVault(0x1635b506a88fBF428465Ad65d00e8d6B6E5846C3);\r\n    Tether public constant USDT = Tether(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\r\n    IERC20 public constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    CurveThreeCryptoPool public constant THREECRYPTO = CurveThreeCryptoPool(0xD51a44d3FaE010294C616388b506AcdA1bfAAE46);\r\n\r\n    constructor() {\r\n        WETH.approve(address(THREECRYPTO), type(uint256).max);\r\n        USDT.approve(address(MIM3POOL), type(uint256).max);\r\n    }\r\n\r\n    /// @inheritdoc ISwapperGeneric\r\n    function swap(\r\n        IERC20,\r\n        IERC20,\r\n        address recipient,\r\n        uint256 shareToMin,\r\n        uint256 shareFrom\r\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\r\n        DEGENBOX.withdraw(IERC20(address(YVCVXETH)), address(this), address(this), 0, shareFrom);\r\n\r\n        // Yearn CVXETH -> Curve CVXETH\r\n        uint256 cvxEthAmount = YVCVXETH.withdraw();\r\n\r\n        // Curve CVXETH -> WETH\r\n        uint256 wethAmount = CVXETHPOOL.remove_liquidity_one_coin(cvxEthAmount, uint256(0), 0);\r\n\r\n        // WETH -> USDT\r\n        THREECRYPTO.exchange(2, 0, wethAmount, 0);\r\n\r\n        // USDT -> MIM\r\n        uint256 mimAmount = MIM3POOL.exchange_underlying(3, 0, USDT.balanceOf(address(this)), 0, address(DEGENBOX));\r\n\r\n        (, shareReturned) = DEGENBOX.deposit(MIM, address(DEGENBOX), recipient, mimAmount, 0);\r\n        extraShare = shareReturned - shareToMin;\r\n    }\r\n\r\n    /// @inheritdoc ISwapperGeneric\r\n    function swapExact(\r\n        IERC20,\r\n        IERC20,\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) public pure override returns (uint256 shareUsed, uint256 shareReturned) {\r\n        return (0, 0);\r\n    }\r\n}\r\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    },
    "contracts/interfaces/IBentoBoxV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.12;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\ninterface IBentoBoxV1 {\r\n    function withdraw(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256, uint256);\r\n\r\n    function deposit(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256, uint256);\r\n}\r\n"
    },
    "contracts/interfaces/curve/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.12;\r\n\r\ninterface CurvePool {\r\n    function exchange_underlying(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256 min_dy,\r\n        address receiver\r\n    ) external returns (uint256);\r\n\r\n    function exchange(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256 min_dy,\r\n        address receiver\r\n    ) external returns (uint256);\r\n\r\n    function get_dy_underlying(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx\r\n    ) external view returns (uint256);\r\n\r\n    function get_dy(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n\r\n    function add_liquidity(uint256[2] memory amounts, uint256 _min_mint_amount) external;\r\n    function add_liquidity(uint256[3] memory amounts, uint256 _min_mint_amount) external;\r\n    function add_liquidity(uint256[4] memory amounts, uint256 _min_mint_amount) external;\r\n\r\n    function remove_liquidity_one_coin(uint256 tokenAmount, int128 i, uint256 min_amount) external returns(uint256);\r\n    function remove_liquidity_one_coin(uint256 tokenAmount, uint256 i, uint256 min_amount) external returns(uint256);\r\n    function remove_liquidity_one_coin(uint256 tokenAmount, int128 i, uint256 min_amount, address receiver) external returns(uint256);\r\n}"
    },
    "contracts/interfaces/curve/ICurveThreeCryptoPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.12;\r\n\r\ninterface CurveThreeCryptoPool {\r\n    function exchange(\r\n        uint256 i,\r\n        uint256 j,\r\n        uint256 dx,\r\n        uint256 min_dy\r\n    ) payable external;\r\n\r\n    function get_dy(\r\n        uint256 i,\r\n        uint256 j,\r\n        uint256 dx\r\n    ) external view returns (uint256);\r\n\r\n    function add_liquidity(uint256[3] memory amounts, uint256 _min_mint_amount) external;\r\n}\r\n"
    },
    "contracts/interfaces/yearn/IYearnVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.12;\r\n\r\ninterface IYearnVault {\r\n    function withdraw() external returns (uint256);\r\n    function deposit(uint256 amount, address recipient) external returns (uint256);\r\n}"
    },
    "contracts/interfaces/Tether.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.12;\r\n\r\ninterface Tether {\r\n    function approve(address spender, uint256 value) external;\r\n\r\n    function balanceOf(address user) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external;\r\n}\r\n"
    },
    "contracts/interfaces/ISwapperGeneric.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >= 0.6.12;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\ninterface ISwapperGeneric {\r\n    /// @notice Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\r\n    /// Swaps it for at least 'amountToMin' of token 'to'.\r\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\r\n    /// Returns the amount of tokens 'to' transferred to BentoBox.\r\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\r\n    function swap(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        address recipient,\r\n        uint256 shareToMin,\r\n        uint256 shareFrom\r\n    ) external returns (uint256 extraShare, uint256 shareReturned);\r\n\r\n    /// @notice Calculates the amount of token 'from' needed to complete the swap (amountFrom),\r\n    /// this should be less than or equal to amountFromMax.\r\n    /// Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\r\n    /// Swaps it for exactly 'exactAmountTo' of token 'to'.\r\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\r\n    /// Transfers allocated, but unused 'from' tokens within the BentoBox to 'refundTo' (amountFromMax - amountFrom).\r\n    /// Returns the amount of 'from' tokens withdrawn from BentoBox (amountFrom).\r\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\r\n    function swapExact(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        address recipient,\r\n        address refundTo,\r\n        uint256 shareFromSupplied,\r\n        uint256 shareToExact\r\n    ) external returns (uint256 shareUsed, uint256 shareReturned);\r\n}\r\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.12;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /// @notice EIP 2612\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n"
    },
    "contracts/swappers/Liquidations/YVMIM3CRVSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\r\nimport \"../../interfaces/IBentoBoxV1.sol\";\r\nimport \"../../interfaces/curve/ICurvePool.sol\";\r\nimport \"../../interfaces/yearn/IYearnVault.sol\";\r\nimport \"../../interfaces/ISwapperGeneric.sol\";\r\n\r\ncontract YVMIM3CRVSwapper is ISwapperGeneric {\r\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\r\n    CurvePool public constant MIM3CRV = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\r\n    IYearnVault public constant YVMIM3CRV = IYearnVault(0x2DfB14E32e2F8156ec15a2c21c3A6c053af52Be8);\r\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\r\n\r\n    constructor() {}\r\n\r\n    /// @inheritdoc ISwapperGeneric\r\n    function swap(\r\n        IERC20,\r\n        IERC20,\r\n        address recipient,\r\n        uint256 shareToMin,\r\n        uint256 shareFrom\r\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\r\n        DEGENBOX.withdraw(IERC20(address(YVMIM3CRV)), address(this), address(this), 0, shareFrom);\r\n\r\n        // Yearn YVMIM3CRV -> Curve MIM3CRV\r\n        uint256 mim3CrvAmount = YVMIM3CRV.withdraw();\r\n\r\n        // Curve MIM3CRV -> MIM\r\n        uint256 mimAmount = MIM3CRV.remove_liquidity_one_coin(mim3CrvAmount, 0, 0, address(DEGENBOX));\r\n\r\n        (, shareReturned) = DEGENBOX.deposit(MIM, address(DEGENBOX), recipient, mimAmount, 0);\r\n        extraShare = shareReturned - shareToMin;\r\n    }\r\n\r\n    /// @inheritdoc ISwapperGeneric\r\n    function swapExact(\r\n        IERC20,\r\n        IERC20,\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) public pure override returns (uint256 shareUsed, uint256 shareReturned) {\r\n        return (0, 0);\r\n    }\r\n}\r\n"
    },
    "contracts/swappers/Leverage/YVMIM3CRVLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\r\nimport \"../../interfaces/IBentoBoxV1.sol\";\r\nimport \"../../interfaces/yearn/IYearnVault.sol\";\r\nimport \"../../interfaces/ILevSwapperGeneric.sol\";\r\n\r\ninterface CurvePool {\r\n    function add_liquidity(\r\n        address pool,\r\n        uint256[4] memory amounts,\r\n        uint256 _min_mint_amount\r\n    ) external returns (uint256);\r\n}\r\n\r\ncontract YVMIM3CRVLevSwapper is ILevSwapperGeneric {\r\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\r\n    CurvePool public constant THREEPOOL = CurvePool(0xA79828DF1850E8a3A3064576f380D90aECDD3359);\r\n    IERC20 public constant MIM3CRV = IERC20(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\r\n    IYearnVault public constant YVMIM3CRV = IYearnVault(0x2DfB14E32e2F8156ec15a2c21c3A6c053af52Be8);\r\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\r\n\r\n    constructor() {\r\n        MIM.approve(address(THREEPOOL), type(uint256).max);\r\n        MIM3CRV.approve(address(YVMIM3CRV), type(uint256).max);\r\n    }\r\n\r\n    /// @inheritdoc ILevSwapperGeneric\r\n    function swap(\r\n        address recipient,\r\n        uint256 shareToMin,\r\n        uint256 shareFrom\r\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\r\n        (uint256 mimAmount, ) = DEGENBOX.withdraw(MIM, address(this), address(this), 0, shareFrom);\r\n\r\n        // MIM -> MIM3CRV\r\n        // MIM, DAI, USDC, USDT\r\n        uint256[4] memory amounts = [mimAmount, 0, 0, 0];\r\n        uint256 mim3CrvAmount = THREEPOOL.add_liquidity(address(MIM3CRV), amounts, 0);\r\n\r\n        // MIM3CRV -> YVMIM3CRV\r\n        uint256 yvMim3CrvAmount = YVMIM3CRV.deposit(mim3CrvAmount, address(DEGENBOX));\r\n\r\n        (, shareReturned) = DEGENBOX.deposit(IERC20(address(YVMIM3CRV)), address(DEGENBOX), recipient, yvMim3CrvAmount, 0);\r\n        extraShare = shareReturned - shareToMin;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/ILevSwapperGeneric.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.12;\r\n\r\ninterface ILevSwapperGeneric {\r\n    /// @notice Swaps to a flexible amount, from an exact input amount\r\n    function swap(\r\n        address recipient,\r\n        uint256 shareToMin,\r\n        uint256 shareFrom\r\n    ) external returns (uint256 extraShare, uint256 shareReturned);\r\n}\r\n"
    },
    "contracts/swappers/Leverage/YVCVXETHLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\r\nimport \"../../interfaces/IBentoBoxV1.sol\";\r\nimport \"../../interfaces/curve/ICurvePool.sol\";\r\nimport \"../../interfaces/curve/ICurveThreeCryptoPool.sol\";\r\nimport \"../../interfaces/yearn/IYearnVault.sol\";\r\nimport \"../../interfaces/Tether.sol\";\r\nimport \"../../interfaces/ILevSwapperGeneric.sol\";\r\n\r\ncontract YVCVXETHLevSwapper is ILevSwapperGeneric {\r\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\r\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\r\n    CurvePool public constant CVXETHPOOL = CurvePool(0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4);\r\n    IYearnVault public constant YVCVXETH = IYearnVault(0x1635b506a88fBF428465Ad65d00e8d6B6E5846C3);\r\n    Tether public constant USDT = Tether(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\r\n    IERC20 public constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    IERC20 public constant CVXETH = IERC20(0x3A283D9c08E8b55966afb64C515f5143cf907611);\r\n    CurveThreeCryptoPool public constant THREECRYPTO = CurveThreeCryptoPool(0xD51a44d3FaE010294C616388b506AcdA1bfAAE46);\r\n\r\n    constructor() {\r\n        MIM.approve(address(MIM3POOL), type(uint256).max);\r\n        USDT.approve(address(THREECRYPTO), type(uint256).max);\r\n        WETH.approve(address(CVXETHPOOL), type(uint256).max);\r\n        CVXETH.approve(address(YVCVXETH), type(uint256).max);\r\n    }\r\n\r\n    /// @inheritdoc ILevSwapperGeneric\r\n    function swap(\r\n        address recipient,\r\n        uint256 shareToMin,\r\n        uint256 shareFrom\r\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\r\n        (uint256 mimAmount, ) = DEGENBOX.withdraw(MIM, address(this), address(this), 0, shareFrom);\r\n\r\n        // MIM -> USDT\r\n        uint256 usdtAmount = MIM3POOL.exchange_underlying(0, 3, mimAmount, 0, address(this));\r\n\r\n        // USDT -> WETH\r\n        THREECRYPTO.exchange(0, 2, usdtAmount, 0);\r\n\r\n        // WETH -> Curve CVXETH\r\n        uint256[2] memory amounts = [WETH.balanceOf(address(this)), 0];\r\n        CVXETHPOOL.add_liquidity(amounts, 0);\r\n\r\n        // Curve CVXETH -> Yearn CVXETH\r\n        uint256 yvCvxEthAmount = YVCVXETH.deposit(type(uint256).max, address(DEGENBOX));\r\n\r\n        (, shareReturned) = DEGENBOX.deposit(IERC20(address(YVCVXETH)), address(DEGENBOX), recipient, yvCvxEthAmount, 0);\r\n        extraShare = shareReturned - shareToMin;\r\n    }\r\n}\r\n"
    },
    "contracts/swappers/Leverage/UsdcAvaxLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\r\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Router01.sol\";\r\nimport \"../../libraries/Babylonian.sol\";\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IBentoBoxV1 {\r\n    function withdraw(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256, uint256);\r\n\r\n    function deposit(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256, uint256);\r\n}\r\n\r\ncontract UsdcAvaxLevSwapper {\r\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0x1fC83f75499b7620d53757f0b01E2ae626aAE530);\r\n    IUniswapV2Pair public constant USDCAVAX = IUniswapV2Pair(0xA389f9430876455C36478DeEa9769B7Ca4E3DDB1);\r\n    IUniswapV2Pair public constant MIMAVAX = IUniswapV2Pair(0x781655d802670bbA3c89aeBaaEa59D3182fD755D);\r\n    IUniswapV2Router01 public constant ROUTER = IUniswapV2Router01(0x60aE616a2155Ee3d9A68541Ba4544862310933d4);\r\n\r\n    uint256 private constant DEADLINE = 0xf000000000000000000000000000000000000000000000000000000000000000; // ~ placeholder for swap deadline\r\n\r\n    IERC20 public constant MIM = IERC20(0x130966628846BFd36ff31a822705796e8cb8C18D);\r\n    IERC20 public constant WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\r\n    IERC20 public constant USDC = IERC20(0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664);\r\n\r\n    constructor() {\r\n        USDCAVAX.approve(address(DEGENBOX), type(uint256).max);\r\n        WAVAX.approve(address(ROUTER), type(uint256).max);\r\n        USDC.approve(address(ROUTER), type(uint256).max);\r\n    }\r\n\r\n    function _calculateSwapInAmount(uint256 reserveIn, uint256 userIn) internal pure returns (uint256) {\r\n        return (Babylonian.sqrt(reserveIn * ((userIn * 3988000) + (reserveIn * 3988009))) - (reserveIn * 1997)) / 1994;\r\n    }\r\n\r\n    function _getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountOut) {\r\n        uint256 amountInWithFee = amountIn * 997;\r\n        uint256 numerator = amountInWithFee * reserveOut;\r\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // Swaps to a flexible amount, from an exact input amount\r\n    function swap(\r\n        address recipient,\r\n        uint256 shareToMin,\r\n        uint256 shareFrom\r\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\r\n        (uint256 amountFrom, ) = DEGENBOX.withdraw(MIM, address(this), address(this), 0, shareFrom);\r\n\r\n        // Swap MIM to AVAX\r\n        (uint256 reserve0, uint256 reserve1, ) = MIMAVAX.getReserves();\r\n        uint256 avaxFromMim = _getAmountOut(amountFrom, reserve0, reserve1);\r\n        MIM.transfer(address(MIMAVAX), amountFrom);\r\n        MIMAVAX.swap(0, avaxFromMim, address(this), new bytes(0));\r\n\r\n        // Determine optimal amount of AVAX to swap for liquidity providing\r\n        (reserve0, reserve1, ) = USDCAVAX.getReserves();\r\n        uint256 avaxSwapInAmount = _calculateSwapInAmount(reserve1, avaxFromMim);\r\n        uint256 usdcAmount = _getAmountOut(avaxSwapInAmount, reserve1, reserve0);\r\n        WAVAX.transfer(address(USDCAVAX), avaxSwapInAmount);\r\n        USDCAVAX.swap(usdcAmount, 0, address(this), \"\");\r\n\r\n        ROUTER.addLiquidity(\r\n            address(USDC),\r\n            address(WAVAX),\r\n            USDC.balanceOf(address(this)),\r\n            WAVAX.balanceOf(address(this)),\r\n            1,\r\n            1,\r\n            address(this),\r\n            DEADLINE\r\n        );\r\n\r\n        (, shareReturned) = DEGENBOX.deposit(IERC20(address(USDCAVAX)), address(this), recipient, USDCAVAX.balanceOf(address(this)), 0);\r\n        extraShare = shareReturned - shareToMin;\r\n    }\r\n}\r\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}"
    },
    "contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity >=0.8.4;\r\n\r\n/// @notice Babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method).\r\nlibrary Babylonian {\r\n    // computes square roots using the babylonian method\r\n    // credit for this implementation goes to\r\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\r\n    function sqrt(uint256 x) internal pure returns (uint256) {\r\n        if (x == 0) return 0;\r\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\r\n        // however that code costs significantly more gas\r\n        uint256 xx = x;\r\n        uint256 r = 1;\r\n        if (xx >= 0x100000000000000000000000000000000) {\r\n            xx >>= 128;\r\n            r <<= 64;\r\n        }\r\n        if (xx >= 0x10000000000000000) {\r\n            xx >>= 64;\r\n            r <<= 32;\r\n        }\r\n        if (xx >= 0x100000000) {\r\n            xx >>= 32;\r\n            r <<= 16;\r\n        }\r\n        if (xx >= 0x10000) {\r\n            xx >>= 16;\r\n            r <<= 8;\r\n        }\r\n        if (xx >= 0x100) {\r\n            xx >>= 8;\r\n            r <<= 4;\r\n        }\r\n        if (xx >= 0x10) {\r\n            xx >>= 4;\r\n            r <<= 2;\r\n        }\r\n        if (xx >= 0x8) {\r\n            r <<= 1;\r\n        }\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1; // Seven iterations should be enough\r\n        uint256 r1 = x / r;\r\n        return (r < r1 ? r : r1);\r\n    }\r\n}\r\n"
    },
    "contracts/swappers/Leverage/MimAvaxLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\r\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Router01.sol\";\r\nimport \"../../libraries/Babylonian.sol\";\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IBentoBoxV1 {\r\n    function withdraw(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256, uint256);\r\n\r\n    function deposit(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256, uint256);\r\n}\r\n\r\ncontract MimAvaxLevSwapper {\r\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0x1fC83f75499b7620d53757f0b01E2ae626aAE530);\r\n    IUniswapV2Pair public constant MIMAVAX = IUniswapV2Pair(0xcBb424fd93cDeC0EF330d8A8C985E8b147F62339);\r\n    IUniswapV2Router01 public constant ROUTER = IUniswapV2Router01(0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506);\r\n\r\n    uint256 private constant DEADLINE = 0xf000000000000000000000000000000000000000000000000000000000000000; // ~ placeholder for swap deadline\r\n\r\n    IERC20 public constant MIM = IERC20(0x130966628846BFd36ff31a822705796e8cb8C18D);\r\n    IERC20 public constant WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\r\n\r\n    constructor() {\r\n        MIMAVAX.approve(address(DEGENBOX), type(uint256).max);\r\n        MIM.approve(address(ROUTER), type(uint256).max);\r\n        WAVAX.approve(address(ROUTER), type(uint256).max);\r\n    }\r\n\r\n    function _calculateSwapInAmount(uint256 reserveIn, uint256 userIn) internal pure returns (uint256) {\r\n        return (Babylonian.sqrt(reserveIn * ((userIn * 3988000) + (reserveIn * 3988009))) - (reserveIn * 1997)) / 1994;\r\n    }\r\n\r\n    function _getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountOut) {\r\n        uint256 amountInWithFee = amountIn * 997;\r\n        uint256 numerator = amountInWithFee * reserveOut;\r\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // Swaps to a flexible amount, from an exact input amount\r\n    function swap(\r\n        address recipient,\r\n        uint256 shareToMin,\r\n        uint256 shareFrom\r\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\r\n        (uint256 amountFrom, ) = DEGENBOX.withdraw(MIM, address(this), address(this), 0, shareFrom);\r\n\r\n        // Determine optimal amount of AVAX to swap for liquidity providing\r\n        (uint256 reserve0, uint256 reserve1, ) = MIMAVAX.getReserves();\r\n        uint256 mimSwapInAmount = _calculateSwapInAmount(reserve0, amountFrom);\r\n        uint256 avaxAmount = _getAmountOut(mimSwapInAmount, reserve0, reserve1);\r\n        MIM.transfer(address(MIMAVAX), mimSwapInAmount);\r\n        MIMAVAX.swap(0, avaxAmount, address(this), \"\");\r\n\r\n        ROUTER.addLiquidity(\r\n            address(MIM),\r\n            address(WAVAX),\r\n            MIM.balanceOf(address(this)),\r\n            WAVAX.balanceOf(address(this)),\r\n            1,\r\n            1,\r\n            address(this),\r\n            DEADLINE\r\n        );\r\n\r\n        (, shareReturned) = DEGENBOX.deposit(IERC20(address(MIMAVAX)), address(this), recipient, MIMAVAX.balanceOf(address(this)), 0);\r\n        extraShare = shareReturned - shareToMin;\r\n    }\r\n}\r\n"
    },
    "contracts/swappers/Leverage/AvaxUsdtLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\r\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Router01.sol\";\r\nimport \"../../libraries/Babylonian.sol\";\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IBentoBoxV1 {\r\n    function withdraw(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256, uint256);\r\n\r\n    function deposit(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256, uint256);\r\n}\r\n\r\ncontract AvaxUsdtLevSwapper {\r\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0x1fC83f75499b7620d53757f0b01E2ae626aAE530);\r\n    IUniswapV2Pair public constant AVAXUSDT = IUniswapV2Pair(0xeD8CBD9F0cE3C6986b22002F03c6475CEb7a6256);\r\n    IUniswapV2Pair public constant MIMAVAX = IUniswapV2Pair(0x781655d802670bbA3c89aeBaaEa59D3182fD755D);\r\n    IUniswapV2Router01 public constant ROUTER = IUniswapV2Router01(0x60aE616a2155Ee3d9A68541Ba4544862310933d4);\r\n\r\n    uint256 private constant DEADLINE = 0xf000000000000000000000000000000000000000000000000000000000000000; // ~ placeholder for swap deadline\r\n\r\n    IERC20 public constant MIM = IERC20(0x130966628846BFd36ff31a822705796e8cb8C18D);\r\n    IERC20 public constant WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\r\n    IERC20 public constant USDT = IERC20(0xc7198437980c041c805A1EDcbA50c1Ce5db95118);\r\n\r\n    constructor() {\r\n        AVAXUSDT.approve(address(DEGENBOX), type(uint256).max);\r\n        WAVAX.approve(address(ROUTER), type(uint256).max);\r\n        USDT.approve(address(ROUTER), type(uint256).max);\r\n    }\r\n\r\n    function _calculateSwapInAmount(uint256 reserveIn, uint256 userIn) internal pure returns (uint256) {\r\n        return (Babylonian.sqrt(reserveIn * ((userIn * 3988000) + (reserveIn * 3988009))) - (reserveIn * 1997)) / 1994;\r\n    }\r\n\r\n    function _getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountOut) {\r\n        uint256 amountInWithFee = amountIn * 997;\r\n        uint256 numerator = amountInWithFee * reserveOut;\r\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // Swaps to a flexible amount, from an exact input amount\r\n    function swap(\r\n        address recipient,\r\n        uint256 shareToMin,\r\n        uint256 shareFrom\r\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\r\n        (uint256 amountFrom, ) = DEGENBOX.withdraw(MIM, address(this), address(this), 0, shareFrom);\r\n\r\n        // Swap MIM to AVAX\r\n        (uint256 reserve0, uint256 reserve1, ) = MIMAVAX.getReserves();\r\n        uint256 avaxFromMim = _getAmountOut(amountFrom, reserve0, reserve1);\r\n        MIM.transfer(address(MIMAVAX), amountFrom);\r\n        MIMAVAX.swap(0, avaxFromMim, address(this), new bytes(0));\r\n\r\n        // Determine optimal amount of AVAX to swap for liquidity providing\r\n        (reserve0, reserve1, ) = AVAXUSDT.getReserves();\r\n        uint256 avaxSwapInAmount = _calculateSwapInAmount(reserve0, avaxFromMim);\r\n        uint256 usdtAmount = _getAmountOut(avaxSwapInAmount, reserve0, reserve1);\r\n        WAVAX.transfer(address(AVAXUSDT), avaxSwapInAmount);\r\n        AVAXUSDT.swap(0, usdtAmount, address(this), \"\");\r\n\r\n        ROUTER.addLiquidity(\r\n            address(WAVAX),\r\n            address(USDT),\r\n            WAVAX.balanceOf(address(this)),\r\n            USDT.balanceOf(address(this)),\r\n            1,\r\n            1,\r\n            address(this),\r\n            DEADLINE\r\n        );\r\n\r\n        (, shareReturned) = DEGENBOX.deposit(IERC20(address(AVAXUSDT)), address(this), recipient, AVAXUSDT.balanceOf(address(this)), 0);\r\n        extraShare = shareReturned - shareToMin;\r\n    }\r\n}\r\n"
    },
    "contracts/oracles/YVMIM3CRVOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\nimport \"../interfaces/IOracle.sol\";\r\n\r\n// Chainlink Aggregator\r\n\r\ninterface IAggregator {\r\n    function latestAnswer() external view returns (int256 answer);\r\n}\r\n\r\ninterface IYearnVault {\r\n    function pricePerShare() external view returns (uint256 price);\r\n}\r\n\r\ninterface ICurvePool {\r\n    function get_virtual_price() external view returns (uint256 price);\r\n}\r\n\r\ncontract YVMIM3CRVOracle is IOracle {\r\n    ICurvePool public constant MIM3CRV = ICurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\r\n    IYearnVault public constant YVMIM3CRV = IYearnVault(0x2DfB14E32e2F8156ec15a2c21c3A6c053af52Be8);\r\n    IAggregator public constant MIM = IAggregator(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\r\n    IAggregator constant public DAI = IAggregator(0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9);\r\n    IAggregator constant public USDC = IAggregator(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6);\r\n    IAggregator constant public USDT = IAggregator(0x3E7d1eAB13ad0104d2750B8863b489D65364e32D);\r\n    \r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    // FROM: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6d97f0919547df11be9443b54af2d90631eaa733/contracts/utils/math/Math.sol\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    // Calculates the lastest exchange rate\r\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\r\n    function _get() internal view returns (uint256) {\r\n        uint256 minStable = min(\r\n            uint256(DAI.latestAnswer()),\r\n            min(uint256(USDC.latestAnswer()), min(uint256(USDT.latestAnswer()), uint256(MIM.latestAnswer())))\r\n        );\r\n\r\n        uint256 yVCurvePrice = MIM3CRV.get_virtual_price() * minStable * YVMIM3CRV.pricePerShare();\r\n\r\n        return 1e62 / yVCurvePrice;\r\n    }\r\n\r\n    // Get the latest exchange rate\r\n    /// @inheritdoc IOracle\r\n    function get(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the last exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peek(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the current spot exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\r\n        (, rate) = peek(data);\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function name(bytes calldata) public pure override returns (string memory) {\r\n        return \"Chainlink MIM3CRV\";\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function symbol(bytes calldata) public pure override returns (string memory) {\r\n        return \"LINK/MIM3CRV\";\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.12;\r\n\r\ninterface IOracle {\r\n    /// @notice Get the latest exchange rate.\r\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\r\n    /// For example:\r\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\r\n    /// @return success if no valid (recent) rate is available, return false else true.\r\n    /// @return rate The rate of the requested asset / pair / pool.\r\n    function get(bytes calldata data) external returns (bool success, uint256 rate);\r\n\r\n    /// @notice Check the last exchange rate without any state changes.\r\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\r\n    /// For example:\r\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\r\n    /// @return success if no valid (recent) rate is available, return false else true.\r\n    /// @return rate The rate of the requested asset / pair / pool.\r\n    function peek(bytes calldata data) external view returns (bool success, uint256 rate);\r\n\r\n    /// @notice Check the current spot exchange rate without any state changes. For oracles like TWAP this will be different from peek().\r\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\r\n    /// For example:\r\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\r\n    /// @return rate The rate of the requested asset / pair / pool.\r\n    function peekSpot(bytes calldata data) external view returns (uint256 rate);\r\n\r\n    /// @notice Returns a human readable (short) name about this oracle.\r\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\r\n    /// For example:\r\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\r\n    /// @return (string) A human readable symbol name about this oracle.\r\n    function symbol(bytes calldata data) external view returns (string memory);\r\n\r\n    /// @notice Returns a human readable name about this oracle.\r\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\r\n    /// For example:\r\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\r\n    /// @return (string) A human readable name about this oracle.\r\n    function name(bytes calldata data) external view returns (string memory);\r\n}\r\n"
    },
    "contracts/oracles/YVIronBankOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\nimport \"../interfaces/IOracle.sol\";\r\n\r\n// Chainlink Aggregator\r\n\r\ninterface IAggregator {\r\n    function latestAnswer() external view returns (int256 answer);\r\n}\r\n\r\ninterface IYearnVault {\r\n    function pricePerShare() external view returns (uint256 price);\r\n}\r\n\r\ninterface ICurvePool {\r\n    function get_virtual_price() external view returns (uint256 price);\r\n}\r\n\r\ncontract YVIronBankOracle is IOracle {\r\n    ICurvePool public constant IronBank = ICurvePool(0x2dded6Da1BF5DBdF597C45fcFaa3194e53EcfeAF);\r\n    IYearnVault public constant YVIB = IYearnVault(0x27b7b1ad7288079A66d12350c828D3C00A6F07d7);\r\n    IAggregator public constant DAI = IAggregator(0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9);\r\n    IAggregator public constant USDC = IAggregator(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6);\r\n    IAggregator public constant USDT = IAggregator(0x3E7d1eAB13ad0104d2750B8863b489D65364e32D);\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    // FROM: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6d97f0919547df11be9443b54af2d90631eaa733/contracts/utils/math/Math.sol\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    // Calculates the lastest exchange rate\r\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\r\n    function _get() internal view returns (uint256) {\r\n        // As the price should never be negative, the unchecked conversion is acceptable\r\n        uint256 minStable = min(uint256(DAI.latestAnswer()), min(uint256(USDC.latestAnswer()), uint256(USDT.latestAnswer())));\r\n\r\n        uint256 yVCurvePrice = IronBank.get_virtual_price() * minStable * YVIB.pricePerShare();\r\n\r\n        return 1e62 / yVCurvePrice;\r\n    }\r\n\r\n    // Get the latest exchange rate\r\n    /// @inheritdoc IOracle\r\n    function get(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the last exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peek(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the current spot exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\r\n        (, rate) = peek(data);\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function name(bytes calldata) public pure override returns (string memory) {\r\n        return \"Yearn Chainlink Curve IronBank\";\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function symbol(bytes calldata) public pure override returns (string memory) {\r\n        return \"LINK/yvIB\";\r\n    }\r\n}\r\n"
    },
    "contracts/oracles/YVCVXETHOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\nimport \"../interfaces/IOracle.sol\";\r\n\r\n// Chainlink Aggregator\r\n\r\ninterface IAggregator {\r\n    function latestAnswer() external view returns (int256 answer);\r\n}\r\n\r\ninterface IYearnVault {\r\n    function pricePerShare() external view returns (uint256 price);\r\n}\r\n\r\ninterface ICurvePool {\r\n    function get_virtual_price() external view returns (uint256 price);\r\n    function lp_price() external view returns (uint256 price);\r\n}\r\n\r\ncontract YVCVXETHOracle is IOracle {\r\n    ICurvePool public constant CVXETH = ICurvePool(0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4);\r\n    IYearnVault public constant YVCVXETH = IYearnVault(0x1635b506a88fBF428465Ad65d00e8d6B6E5846C3);\r\n    IAggregator public constant ETH = IAggregator(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\r\n\r\n    // Calculates the lastest exchange rate\r\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\r\n    function _get() internal view returns (uint256) {\r\n        uint256 yVCurvePrice = CVXETH.lp_price() * uint256(ETH.latestAnswer()) * YVCVXETH.pricePerShare();\r\n\r\n        return 1e62 / yVCurvePrice;\r\n    }\r\n\r\n    // Get the latest exchange rate\r\n    /// @inheritdoc IOracle\r\n    function get(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the last exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peek(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the current spot exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\r\n        (, rate) = peek(data);\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function name(bytes calldata) public pure override returns (string memory) {\r\n        return \"Chainlink CVXETH\";\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function symbol(bytes calldata) public pure override returns (string memory) {\r\n        return \"LINK/CVXETH\";\r\n    }\r\n}\r\n"
    },
    "contracts/oracles/YVCrvStETHOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\nimport \"../interfaces/IOracle.sol\";\r\n\r\n// Chainlink Aggregator\r\n\r\ninterface IAggregator {\r\n    function latestAnswer() external view returns (int256 answer);\r\n}\r\n\r\ninterface IYearnVault {\r\n    function pricePerShare() external view returns (uint256 price);\r\n}\r\n\r\ninterface ICurvePool {\r\n    function get_virtual_price() external view returns (uint256 price);\r\n}\r\n\r\ncontract YVCrvStETHOracle is IOracle {\r\n    ICurvePool public constant STETH = ICurvePool(0xDC24316b9AE028F1497c275EB9192a3Ea0f67022);\r\n    IYearnVault public constant YVSTETH = IYearnVault(0xdCD90C7f6324cfa40d7169ef80b12031770B4325);\r\n    IAggregator public constant ETH = IAggregator(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    // FROM: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6d97f0919547df11be9443b54af2d90631eaa733/contracts/utils/math/Math.sol\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    // Calculates the lastest exchange rate\r\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\r\n    function _get() internal view returns (uint256) {\r\n        uint256 yVCurvePrice = STETH.get_virtual_price() * uint256(ETH.latestAnswer()) * YVSTETH.pricePerShare();\r\n\r\n        return 1e62 / yVCurvePrice;\r\n    }\r\n\r\n    // Get the latest exchange rate\r\n    /// @inheritdoc IOracle\r\n    function get(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the last exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peek(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the current spot exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\r\n        (, rate) = peek(data);\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function name(bytes calldata) public pure override returns (string memory) {\r\n        return \"Yearn Chainlink Curve STETH\";\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function symbol(bytes calldata) public pure override returns (string memory) {\r\n        return \"LINK/yvCRVSTETH\";\r\n    }\r\n}\r\n"
    },
    "contracts/oracles/WethOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\nimport \"../interfaces/IOracle.sol\";\r\n\r\n// Chainlink Aggregator\r\n\r\ninterface IAggregator {\r\n    function latestAnswer() external view returns (int256 answer);\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ncontract WethOracle is IOracle {\r\n    IAggregator public constant ETHUSD = IAggregator(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\r\n\r\n    // Calculates the lastest exchange rate\r\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\r\n    function _get() internal view returns (uint256) {\r\n        return 1e26 / uint256(ETHUSD.latestAnswer());\r\n    }\r\n\r\n    // Get the latest exchange rate\r\n    /// @inheritdoc IOracle\r\n    function get(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the last exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peek(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the current spot exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\r\n        (, rate) = peek(data);\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function name(bytes calldata) public pure override returns (string memory) {\r\n        return \"Chainlink ETH\";\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function symbol(bytes calldata) public pure override returns (string memory) {\r\n        return \"LINK/ETH\";\r\n    }\r\n}\r\n"
    },
    "contracts/oracles/USTOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\nimport \"../interfaces/IOracle.sol\";\r\n\r\n// Chainlink Aggregator\r\n\r\ninterface IAggregator {\r\n    function latestAnswer() external view returns (int256 answer);\r\n}\r\n\r\ncontract USTOracle is IOracle {\r\n    IAggregator public constant UST = IAggregator(0x8b6d9085f310396C6E4f0012783E9f850eaa8a82);\r\n\r\n    // Calculates the lastest exchange rate\r\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\r\n    function _get() internal view returns (uint256) {\r\n        uint256 ustPrice = uint256(UST.latestAnswer());\r\n\r\n        return 1e26 / ustPrice;\r\n    }\r\n\r\n    // Get the latest exchange rate\r\n    /// @inheritdoc IOracle\r\n    function get(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the last exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peek(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the current spot exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\r\n        (, rate) = peek(data);\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function name(bytes calldata) public pure override returns (string memory) {\r\n        return \"Chainlink UST\";\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function symbol(bytes calldata) public pure override returns (string memory) {\r\n        return \"LINK/UST\";\r\n    }\r\n}\r\n"
    },
    "contracts/oracles/sSpellOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\nimport \"../interfaces/IOracle.sol\";\r\n\r\n// Chainlink Aggregator\r\n\r\ninterface IAggregator {\r\n    function latestAnswer() external view returns (int256 answer);\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ncontract sSpellOracle is IOracle {\r\n    IAggregator public constant SPELLUSD = IAggregator(0x8c110B94C5f1d347fAcF5E1E938AB2db60E3c9a8);\r\n\r\n    IERC20 public constant SSPELL = IERC20(0x26FA3fFFB6EfE8c1E69103aCb4044C26B9A106a9);\r\n    IERC20 public constant SPELL = IERC20(0x090185f2135308BaD17527004364eBcC2D37e5F6);\r\n\r\n    function toSSpell(uint256 amount) internal view returns (uint256) {\r\n        return (amount * SPELL.balanceOf(address(SSPELL))) / SSPELL.totalSupply();\r\n    }\r\n\r\n    // Calculates the lastest exchange rate\r\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\r\n    function _get() internal view returns (uint256) {\r\n        return 1e26 / toSSpell(uint256(SPELLUSD.latestAnswer()));\r\n    }\r\n\r\n    // Get the latest exchange rate\r\n    /// @inheritdoc IOracle\r\n    function get(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the last exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peek(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the current spot exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\r\n        (, rate) = peek(data);\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function name(bytes calldata) public pure override returns (string memory) {\r\n        return \"Chainlink sSpell\";\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function symbol(bytes calldata) public pure override returns (string memory) {\r\n        return \"LINK/sSpell\";\r\n    }\r\n}\r\n"
    },
    "contracts/oracles/SpellOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\nimport \"../interfaces/IOracle.sol\";\r\n\r\n// Chainlink Aggregator\r\n\r\ninterface IAggregator {\r\n    function latestAnswer() external view returns (int256 answer);\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ncontract SpellOracle is IOracle {\r\n    IAggregator public constant SPELLUSD = IAggregator(0x8c110B94C5f1d347fAcF5E1E938AB2db60E3c9a8);\r\n\r\n    // Calculates the lastest exchange rate\r\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\r\n    function _get() internal view returns (uint256) {\r\n        return 1e26 / uint256(SPELLUSD.latestAnswer());\r\n    }\r\n\r\n    // Get the latest exchange rate\r\n    /// @inheritdoc IOracle\r\n    function get(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the last exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peek(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the current spot exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\r\n        (, rate) = peek(data);\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function name(bytes calldata) public pure override returns (string memory) {\r\n        return \"Chainlink Spell\";\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function symbol(bytes calldata) public pure override returns (string memory) {\r\n        return \"LINK/Spell\";\r\n    }\r\n}\r\n"
    },
    "contracts/oracles/RenBTCCrvOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\nimport \"../interfaces/IOracle.sol\";\r\n\r\n// Chainlink Aggregator\r\n\r\ninterface IAggregator {\r\n    function latestAnswer() external view returns (int256 answer);\r\n}\r\n\r\ninterface ICurvePool {\r\n    function get_virtual_price() external view returns (uint256 price);\r\n}\r\n\r\ncontract RenBTCCrvOracle is IOracle {\r\n    ICurvePool public constant renCrv = ICurvePool(0x93054188d876f558f4a66B2EF1d97d16eDf0895B);\r\n    IAggregator public constant BTC = IAggregator(0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    // FROM: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6d97f0919547df11be9443b54af2d90631eaa733/contracts/utils/math/Math.sol\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    // Calculates the lastest exchange rate\r\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\r\n    function _get() internal view returns (uint256) {\r\n        // As the price should never be negative, the unchecked conversion is acceptable\r\n        uint256 renCrvPrice = renCrv.get_virtual_price() * uint256(BTC.latestAnswer());\r\n\r\n        return 1e44 / renCrvPrice;\r\n    }\r\n\r\n    // Get the latest exchange rate\r\n    /// @inheritdoc IOracle\r\n    function get(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the last exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peek(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the current spot exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\r\n        (, rate) = peek(data);\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function name(bytes calldata) public pure override returns (string memory) {\r\n        return \"Chainlink Ren Swap\";\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function symbol(bytes calldata) public pure override returns (string memory) {\r\n        return \"LINK/RenCrv\";\r\n    }\r\n}\r\n"
    },
    "contracts/oracles/FTMOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\nimport \"../interfaces/IOracle.sol\";\r\n\r\n// Chainlink Aggregator\r\n\r\ninterface IAggregator {\r\n    function latestAnswer() external view returns (int256 answer);\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ncontract FTMOracle is IOracle {\r\n    IAggregator constant public FTMUSD = IAggregator(0xf4766552D15AE4d256Ad41B6cf2933482B0680dc);\r\n\r\n    // Calculates the lastest exchange rate\r\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\r\n    function _get() internal view returns (uint256) {\r\n\r\n        return 1e26 / uint256(FTMUSD.latestAnswer());\r\n    }\r\n\r\n    // Get the latest exchange rate\r\n    /// @inheritdoc IOracle\r\n    function get(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the last exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peek(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the current spot exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\r\n        (, rate) = peek(data);\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function name(bytes calldata) public pure override returns (string memory) {\r\n        return \"Chainlink FTM\";\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function symbol(bytes calldata) public pure override returns (string memory) {\r\n        return \"LINK/FTM\";\r\n    }\r\n}\r\n"
    },
    "contracts/oracles/Frax3CrvOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\nimport \"../interfaces/IOracle.sol\";\r\n\r\n// Chainlink Aggregator\r\n\r\ninterface IAggregator {\r\n    function latestAnswer() external view returns (int256 answer);\r\n}\r\n\r\ninterface IYearnVault {\r\n    function pricePerShare() external view returns (uint256 price);\r\n}\r\n\r\ninterface ICurvePool {\r\n    function get_virtual_price() external view returns (uint256 price);\r\n}\r\n\r\ncontract Frax3CrvOracle is IOracle {\r\n    ICurvePool public constant frax3crv = ICurvePool(0xd632f22692FaC7611d2AA1C0D552930D43CAEd3B);\r\n    IAggregator public constant FRAX = IAggregator(0xB9E1E3A9feFf48998E45Fa90847ed4D467E8BcfD);\r\n    IAggregator public constant DAI = IAggregator(0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9);\r\n    IAggregator public constant USDC = IAggregator(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6);\r\n    IAggregator public constant USDT = IAggregator(0x3E7d1eAB13ad0104d2750B8863b489D65364e32D);\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    // FROM: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6d97f0919547df11be9443b54af2d90631eaa733/contracts/utils/math/Math.sol\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    // Calculates the lastest exchange rate\r\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\r\n    function _get() internal view returns (uint256) {\r\n        // As the price should never be negative, the unchecked conversion is acceptable\r\n        uint256 minStable = min(\r\n            uint256(DAI.latestAnswer()),\r\n            min(uint256(USDC.latestAnswer()), min(uint256(USDT.latestAnswer()), uint256(FRAX.latestAnswer())))\r\n        );\r\n\r\n        uint256 yVCurvePrice = frax3crv.get_virtual_price() * minStable;\r\n\r\n        return 1e44 / yVCurvePrice;\r\n    }\r\n\r\n    // Get the latest exchange rate\r\n    /// @inheritdoc IOracle\r\n    function get(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the last exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peek(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the current spot exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\r\n        (, rate) = peek(data);\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function name(bytes calldata) public pure override returns (string memory) {\r\n        return \"Chainlink Frax3Crv\";\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function symbol(bytes calldata) public pure override returns (string memory) {\r\n        return \"LINK/Frax3crv\";\r\n    }\r\n}\r\n"
    },
    "contracts/oracles/CakeOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\nimport \"../interfaces/IOracle.sol\";\r\n\r\n// Chainlink Aggregator\r\n\r\ninterface IAggregator {\r\n    function latestAnswer() external view returns (int256 answer);\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ncontract CakeOracle is IOracle {\r\n    IAggregator public constant BNBUSD = IAggregator(0xB6064eD41d4f67e353768aA239cA86f4F73665a1);\r\n\r\n    // Calculates the lastest exchange rate\r\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\r\n    function _get() internal view returns (uint256) {\r\n        return 1e26 / uint256(BNBUSD.latestAnswer());\r\n    }\r\n\r\n    // Get the latest exchange rate\r\n    /// @inheritdoc IOracle\r\n    function get(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the last exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peek(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the current spot exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\r\n        (, rate) = peek(data);\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function name(bytes calldata) public pure override returns (string memory) {\r\n        return \"Chainlink CAKE\";\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function symbol(bytes calldata) public pure override returns (string memory) {\r\n        return \"LINK/CAKE\";\r\n    }\r\n}\r\n"
    },
    "contracts/oracles/BNBOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\nimport \"../interfaces/IOracle.sol\";\r\n\r\n// Chainlink Aggregator\r\n\r\ninterface IAggregator {\r\n    function latestAnswer() external view returns (int256 answer);\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ncontract BNBOracle is IOracle {\r\n    IAggregator public constant BNBUSD = IAggregator(0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE);\r\n\r\n    // Calculates the lastest exchange rate\r\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\r\n    function _get() internal view returns (uint256) {\r\n        return 1e26 / uint256(BNBUSD.latestAnswer());\r\n    }\r\n\r\n    // Get the latest exchange rate\r\n    /// @inheritdoc IOracle\r\n    function get(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the last exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peek(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the current spot exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\r\n        (, rate) = peek(data);\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function name(bytes calldata) public pure override returns (string memory) {\r\n        return \"Chainlink BNB\";\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function symbol(bytes calldata) public pure override returns (string memory) {\r\n        return \"LINK/BNB\";\r\n    }\r\n}\r\n"
    },
    "contracts/oracles/3CrvOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\nimport \"../interfaces/IOracle.sol\";\r\n\r\n// Chainlink Aggregator\r\n\r\ninterface IAggregator {\r\n    function latestAnswer() external view returns (int256 answer);\r\n}\r\n\r\ninterface IYearnVault {\r\n    function pricePerShare() external view returns (uint256 price);\r\n}\r\n\r\ninterface ICurvePool {\r\n    function get_virtual_price() external view returns (uint256 price);\r\n}\r\n\r\ncontract ThreeCrvOracle is IOracle {\r\n    ICurvePool public constant threecrv = ICurvePool(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);\r\n    IAggregator public constant DAI = IAggregator(0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9);\r\n    IAggregator public constant USDC = IAggregator(0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6);\r\n    IAggregator public constant USDT = IAggregator(0x3E7d1eAB13ad0104d2750B8863b489D65364e32D);\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    // FROM: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/6d97f0919547df11be9443b54af2d90631eaa733/contracts/utils/math/Math.sol\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    // Calculates the lastest exchange rate\r\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\r\n    function _get() internal view returns (uint256) {\r\n        // As the price should never be negative, the unchecked conversion is acceptable\r\n        uint256 minStable = min(uint256(DAI.latestAnswer()), min(uint256(USDC.latestAnswer()), uint256(USDT.latestAnswer())));\r\n\r\n        uint256 yVCurvePrice = threecrv.get_virtual_price() * minStable;\r\n\r\n        return 1e44 / yVCurvePrice;\r\n    }\r\n\r\n    // Get the latest exchange rate\r\n    /// @inheritdoc IOracle\r\n    function get(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the last exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peek(bytes calldata) public view override returns (bool, uint256) {\r\n        return (true, _get());\r\n    }\r\n\r\n    // Check the current spot exchange rate without any state changes\r\n    /// @inheritdoc IOracle\r\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\r\n        (, rate) = peek(data);\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function name(bytes calldata) public pure override returns (string memory) {\r\n        return \"Chainlink 3Crv\";\r\n    }\r\n\r\n    /// @inheritdoc IOracle\r\n    function symbol(bytes calldata) public pure override returns (string memory) {\r\n        return \"LINK/3crv\";\r\n    }\r\n}\r\n"
    },
    "contracts/swappers/Liquidations/USTSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\nimport \"../../interfaces/ISwapperGeneric.sol\";\r\n\r\ninterface CurvePool {\r\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function add_liquidity(uint256[3] memory amounts, uint256 _min_mint_amount) external;\r\n}\r\n\r\ninterface IBentoBoxV1 {\r\n    function withdraw(IERC20 token, address from, address to, uint256 amount, uint256 share) external returns(uint256, uint256);\r\n    function deposit(IERC20 token, address from, address to, uint256 amount, uint256 share) external returns(uint256, uint256);\r\n}\r\n\r\ncontract USTSwapper is ISwapperGeneric {\r\n\r\n    // Local variables\r\n    IBentoBoxV1 public constant degenBox = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\r\n    CurvePool constant public UST2POOL = CurvePool(0x55A8a39bc9694714E2874c1ce77aa1E599461E18);\r\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\r\n    IERC20 public constant UST = IERC20(0xa47c8bf37f92aBed4A126BDA807A7b7498661acD);\r\n\r\n    constructor() public {\r\n        UST.approve(address(UST2POOL), type(uint256).max);\r\n        MIM.approve(address(degenBox), type(uint256).max);\r\n    }\r\n\r\n\r\n    // Swaps to a flexible amount, from an exact input amount\r\n    /// @inheritdoc ISwapperGeneric\r\n    function swap(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        address recipient,\r\n        uint256 shareToMin,\r\n        uint256 shareFrom\r\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\r\n\r\n        (uint256 amountFrom, ) = degenBox.withdraw(UST, address(this), address(this), 0, shareFrom);\r\n\r\n        uint256 amountTo = UST2POOL.exchange(1, 0, amountFrom, 0, address(degenBox));\r\n\r\n        (, shareReturned) = degenBox.deposit(MIM, address(degenBox), recipient, amountTo, 0);\r\n        extraShare = shareReturned - shareToMin;\r\n    }\r\n\r\n    // Swaps to an exact amount, from a flexible input amount\r\n    /// @inheritdoc ISwapperGeneric\r\n    function swapExact(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        address recipient,\r\n        address refundTo,\r\n        uint256 shareFromSupplied,\r\n        uint256 shareToExact\r\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\r\n        return (0,0);\r\n    }\r\n}"
    },
    "contracts/swappers/Liquidations/UsdcAvaxSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\r\nimport \"../../interfaces/ISwapperGeneric.sol\";\r\n\r\ninterface IBentoBoxV1 {\r\n    function withdraw(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256, uint256);\r\n\r\n    function deposit(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256, uint256);\r\n}\r\n\r\ncontract UsdcAvaxSwapper is ISwapperGeneric {\r\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0x1fC83f75499b7620d53757f0b01E2ae626aAE530);\r\n    IUniswapV2Pair public constant USDCAVAX = IUniswapV2Pair(0xA389f9430876455C36478DeEa9769B7Ca4E3DDB1);\r\n    IUniswapV2Pair public constant MIMAVAX = IUniswapV2Pair(0x781655d802670bbA3c89aeBaaEa59D3182fD755D);\r\n    IERC20 public constant MIM = IERC20(0x130966628846BFd36ff31a822705796e8cb8C18D);\r\n    IERC20 public constant WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\r\n    IERC20 public constant USDC = IERC20(0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664);\r\n\r\n    constructor() {\r\n        MIM.approve(address(DEGENBOX), type(uint256).max);\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function _getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountOut) {\r\n        uint256 amountInWithFee = amountIn * 997;\r\n        uint256 numerator = amountInWithFee * reserveOut;\r\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // Swaps to a flexible amount, from an exact input amount\r\n    /// @inheritdoc ISwapperGeneric\r\n    function swap(\r\n        IERC20,\r\n        IERC20,\r\n        address recipient,\r\n        uint256 shareToMin,\r\n        uint256 shareFrom\r\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\r\n        (uint256 amountFrom, ) = DEGENBOX.withdraw(IERC20(address(USDCAVAX)), address(this), address(this), 0, shareFrom);\r\n\r\n        USDCAVAX.transfer(address(USDCAVAX), amountFrom);\r\n        (uint256 usdcAmount, uint256 avaxAmount) = USDCAVAX.burn(address(this));\r\n        \r\n        // swap USDC to AVAX\r\n        (uint256 reserve0, uint256 reserve1, ) = USDCAVAX.getReserves();\r\n        uint256 avaxFromUsdc = _getAmountOut(usdcAmount, reserve0, reserve1);\r\n        USDC.transfer(address(USDCAVAX), usdcAmount);\r\n        USDCAVAX.swap(0, avaxFromUsdc, address(this), new bytes(0));\r\n        avaxAmount += avaxFromUsdc;\r\n\r\n        // swap AVAX to MIM\r\n        (reserve0, reserve1, ) = MIMAVAX.getReserves();\r\n        uint256 mimFromAvax = _getAmountOut(avaxAmount, reserve1, reserve0);\r\n        WAVAX.transfer(address(MIMAVAX), avaxAmount);\r\n        MIMAVAX.swap(mimFromAvax, 0, address(this), new bytes(0));\r\n\r\n        (, shareReturned) = DEGENBOX.deposit(MIM, address(this), recipient, mimFromAvax, 0);\r\n        extraShare = shareReturned - shareToMin;\r\n    }\r\n\r\n    // Swaps to an exact amount, from a flexible input amount\r\n    /// @inheritdoc ISwapperGeneric\r\n    function swapExact(\r\n        IERC20,\r\n        IERC20,\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\r\n        return (0, 0);\r\n    }\r\n}\r\n"
    },
    "contracts/swappers/Liquidations/MimAvaxSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\r\nimport \"../../interfaces/ISwapperGeneric.sol\";\r\n\r\ninterface IBentoBoxV1 {\r\n    function withdraw(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256, uint256);\r\n\r\n    function deposit(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256, uint256);\r\n}\r\n\r\ncontract MimAvaxSwapper is ISwapperGeneric {\r\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0x1fC83f75499b7620d53757f0b01E2ae626aAE530);\r\n    IUniswapV2Pair public constant MIMAVAX = IUniswapV2Pair(0xcBb424fd93cDeC0EF330d8A8C985E8b147F62339);\r\n    IERC20 public constant MIM = IERC20(0x130966628846BFd36ff31a822705796e8cb8C18D);\r\n    IERC20 public constant WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\r\n\r\n    constructor() {\r\n        MIM.approve(address(DEGENBOX), type(uint256).max);\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function _getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountOut) {\r\n        uint256 amountInWithFee = amountIn * 997;\r\n        uint256 numerator = amountInWithFee * reserveOut;\r\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // Swaps to a flexible amount, from an exact input amount\r\n    /// @inheritdoc ISwapperGeneric\r\n    function swap(\r\n        IERC20,\r\n        IERC20,\r\n        address recipient,\r\n        uint256 shareToMin,\r\n        uint256 shareFrom\r\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\r\n        (uint256 amountFrom, ) = DEGENBOX.withdraw(IERC20(address(MIMAVAX)), address(this), address(this), 0, shareFrom);\r\n\r\n        MIMAVAX.transfer(address(MIMAVAX), amountFrom);\r\n        (uint256 mimAmount, uint256 avaxAmount) = MIMAVAX.burn(address(this));\r\n\r\n        // swap AVAX to MIM\r\n        (uint256 reserve0, uint256 reserve1, ) = MIMAVAX.getReserves();\r\n        uint256 mimFromAvax = _getAmountOut(avaxAmount, reserve1, reserve0);\r\n        WAVAX.transfer(address(MIMAVAX), avaxAmount);\r\n        MIMAVAX.swap(mimFromAvax, 0, address(this), new bytes(0));\r\n        mimAmount += mimFromAvax;\r\n\r\n        (, shareReturned) = DEGENBOX.deposit(MIM, address(this), recipient, mimAmount, 0);\r\n        extraShare = shareReturned - shareToMin;\r\n    }\r\n\r\n    // Swaps to an exact amount, from a flexible input amount\r\n    /// @inheritdoc ISwapperGeneric\r\n    function swapExact(\r\n        IERC20,\r\n        IERC20,\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\r\n        return (0, 0);\r\n    }\r\n}\r\n"
    },
    "contracts/swappers/Liquidations/AvaxUsdtSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\r\nimport \"../../interfaces/ISwapperGeneric.sol\";\r\n\r\ninterface IBentoBoxV1 {\r\n    function withdraw(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256, uint256);\r\n\r\n    function deposit(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256, uint256);\r\n}\r\n\r\ncontract AvaxUsdtSwapper is ISwapperGeneric {\r\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0x1fC83f75499b7620d53757f0b01E2ae626aAE530);\r\n    IUniswapV2Pair public constant AVAXUSDT = IUniswapV2Pair(0xeD8CBD9F0cE3C6986b22002F03c6475CEb7a6256);\r\n    IUniswapV2Pair public constant MIMAVAX = IUniswapV2Pair(0x781655d802670bbA3c89aeBaaEa59D3182fD755D);\r\n    IERC20 public constant MIM = IERC20(0x130966628846BFd36ff31a822705796e8cb8C18D);\r\n    IERC20 public constant WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\r\n    IERC20 public constant USDT = IERC20(0xc7198437980c041c805A1EDcbA50c1Ce5db95118);\r\n\r\n    constructor() {\r\n        MIM.approve(address(DEGENBOX), type(uint256).max);\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function _getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountOut) {\r\n        uint256 amountInWithFee = amountIn * 997;\r\n        uint256 numerator = amountInWithFee * reserveOut;\r\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // Swaps to a flexible amount, from an exact input amount\r\n    /// @inheritdoc ISwapperGeneric\r\n    function swap(\r\n        IERC20,\r\n        IERC20,\r\n        address recipient,\r\n        uint256 shareToMin,\r\n        uint256 shareFrom\r\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\r\n        (uint256 amountFrom, ) = DEGENBOX.withdraw(IERC20(address(AVAXUSDT)), address(this), address(this), 0, shareFrom);\r\n\r\n        AVAXUSDT.transfer(address(AVAXUSDT), amountFrom);\r\n        (uint256 avaxAmount, uint256 usdtAmount) = AVAXUSDT.burn(address(this));\r\n        \r\n        // swap USDT to AVAX\r\n        (uint256 reserve0, uint256 reserve1, ) = AVAXUSDT.getReserves();\r\n        uint256 avaxFromUsdt = _getAmountOut(usdtAmount, reserve1, reserve0);\r\n        USDT.transfer(address(AVAXUSDT), usdtAmount);\r\n        AVAXUSDT.swap(avaxFromUsdt, 0, address(this), new bytes(0));\r\n        avaxAmount += avaxFromUsdt;\r\n\r\n        // swap AVAX to MIM\r\n        (reserve0, reserve1, ) = MIMAVAX.getReserves();\r\n        uint256 mimFromAvax = _getAmountOut(avaxAmount, reserve1, reserve0);\r\n        WAVAX.transfer(address(MIMAVAX), avaxAmount);\r\n        MIMAVAX.swap(mimFromAvax, 0, address(this), new bytes(0));\r\n\r\n        (, shareReturned) = DEGENBOX.deposit(MIM, address(this), recipient, mimFromAvax, 0);\r\n        extraShare = shareReturned - shareToMin;\r\n    }\r\n\r\n    // Swaps to an exact amount, from a flexible input amount\r\n    /// @inheritdoc ISwapperGeneric\r\n    function swapExact(\r\n        IERC20,\r\n        IERC20,\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\r\n        return (0, 0);\r\n    }\r\n}\r\n"
    },
    "contracts/swappers/Leverage/USTLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /// @notice EIP 2612\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\ninterface CurvePool {\r\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function add_liquidity(uint256[3] memory amounts, uint256 _min_mint_amount) external;\r\n}\r\n\r\ninterface IBentoBoxV1 {\r\n    function withdraw(IERC20 token, address from, address to, uint256 amount, uint256 share) external returns(uint256, uint256);\r\n    function deposit(IERC20 token, address from, address to, uint256 amount, uint256 share) external returns(uint256, uint256);\r\n}\r\n\r\ncontract USTLevSwapper {\r\n\r\n     // Local variables\r\n    IBentoBoxV1 public constant degenBox = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\r\n    CurvePool constant public UST2POOL = CurvePool(0x55A8a39bc9694714E2874c1ce77aa1E599461E18);\r\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\r\n    IERC20 public constant UST = IERC20(0xa47c8bf37f92aBed4A126BDA807A7b7498661acD);\r\n\r\n    constructor() public {\r\n        MIM.approve(address(UST2POOL), type(uint256).max);\r\n        UST.approve(address(degenBox), type(uint256).max);\r\n    }\r\n\r\n\r\n    // Swaps to a flexible amount, from an exact input amount\r\n    function swap(\r\n        address recipient,\r\n        uint256 shareToMin,\r\n        uint256 shareFrom\r\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\r\n\r\n        (uint256 amountFrom, ) = degenBox.withdraw(MIM, address(this), address(this), 0, shareFrom);\r\n\r\n        uint256 amountTo = UST2POOL.exchange(0, 1, amountFrom, 0, address(degenBox));\r\n\r\n        (, shareReturned) = degenBox.deposit(UST, address(degenBox), recipient, amountTo, 0);\r\n        extraShare = shareReturned - shareToMin;\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}