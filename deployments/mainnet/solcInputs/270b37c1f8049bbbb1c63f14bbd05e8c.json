{
  "language": "Solidity",
  "sources": {
    "contracts/swappers/Leverage/StkFrax3CrvLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIXED\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.2\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n/// @notice A library for performing overflow-/underflow-safe math,\r\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\r\nlibrary BoringMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\r\n    }\r\n\r\n    function to128(uint256 a) internal pure returns (uint128 c) {\r\n        require(a <= uint128(-1), \"BoringMath: uint128 Overflow\");\r\n        c = uint128(a);\r\n    }\r\n\r\n    function to64(uint256 a) internal pure returns (uint64 c) {\r\n        require(a <= uint64(-1), \"BoringMath: uint64 Overflow\");\r\n        c = uint64(a);\r\n    }\r\n\r\n    function to32(uint256 a) internal pure returns (uint32 c) {\r\n        require(a <= uint32(-1), \"BoringMath: uint32 Overflow\");\r\n        c = uint32(a);\r\n    }\r\n}\r\n\r\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\r\nlibrary BoringMath128 {\r\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n}\r\n\r\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.\r\nlibrary BoringMath64 {\r\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n}\r\n\r\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\r\nlibrary BoringMath32 {\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.2\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /// @notice EIP 2612\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.2\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n// solhint-disable avoid-low-level-calls\r\n\r\nlibrary BoringERC20 {\r\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\r\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\r\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\r\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\r\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\r\n\r\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\r\n        if (data.length >= 64) {\r\n            return abi.decode(data, (string));\r\n        } else if (data.length == 32) {\r\n            uint8 i = 0;\r\n            while (i < 32 && data[i] != 0) {\r\n                i++;\r\n            }\r\n            bytes memory bytesArray = new bytes(i);\r\n            for (i = 0; i < 32 && data[i] != 0; i++) {\r\n                bytesArray[i] = data[i];\r\n            }\r\n            return string(bytesArray);\r\n        } else {\r\n            return \"???\";\r\n        }\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\r\n    /// @param token The address of the ERC-20 token contract.\r\n    /// @return (string) Token symbol.\r\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\r\n        return success ? returnDataToString(data) : \"???\";\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\r\n    /// @param token The address of the ERC-20 token contract.\r\n    /// @return (string) Token name.\r\n    function safeName(IERC20 token) internal view returns (string memory) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\r\n        return success ? returnDataToString(data) : \"???\";\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\r\n    /// @param token The address of the ERC-20 token contract.\r\n    /// @return (uint8) Token decimals.\r\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\r\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\r\n    /// Reverts on a failed transfer.\r\n    /// @param token The address of the ERC-20 token.\r\n    /// @param to Transfer tokens to.\r\n    /// @param amount The token amount.\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\r\n    /// Reverts on a failed transfer.\r\n    /// @param token The address of the ERC-20 token.\r\n    /// @param from Transfer tokens from.\r\n    /// @param to Transfer tokens to.\r\n    /// @param amount The token amount.\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\r\n    }\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol@v1.2.2\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nstruct Rebase {\r\n    uint128 elastic;\r\n    uint128 base;\r\n}\r\n\r\n/// @notice A rebasing library using overflow-/underflow-safe math.\r\nlibrary RebaseLibrary {\r\n    using BoringMath for uint256;\r\n    using BoringMath128 for uint128;\r\n\r\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\r\n    function toBase(\r\n        Rebase memory total,\r\n        uint256 elastic,\r\n        bool roundUp\r\n    ) internal pure returns (uint256 base) {\r\n        if (total.elastic == 0) {\r\n            base = elastic;\r\n        } else {\r\n            base = elastic.mul(total.base) / total.elastic;\r\n            if (roundUp && base.mul(total.elastic) / total.base < elastic) {\r\n                base = base.add(1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\r\n    function toElastic(\r\n        Rebase memory total,\r\n        uint256 base,\r\n        bool roundUp\r\n    ) internal pure returns (uint256 elastic) {\r\n        if (total.base == 0) {\r\n            elastic = base;\r\n        } else {\r\n            elastic = base.mul(total.elastic) / total.base;\r\n            if (roundUp && elastic.mul(total.base) / total.elastic < base) {\r\n                elastic = elastic.add(1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\r\n    /// @return (Rebase) The new total.\r\n    /// @return base in relationship to `elastic`.\r\n    function add(\r\n        Rebase memory total,\r\n        uint256 elastic,\r\n        bool roundUp\r\n    ) internal pure returns (Rebase memory, uint256 base) {\r\n        base = toBase(total, elastic, roundUp);\r\n        total.elastic = total.elastic.add(elastic.to128());\r\n        total.base = total.base.add(base.to128());\r\n        return (total, base);\r\n    }\r\n\r\n    /// @notice Sub `base` from `total` and update `total.elastic`.\r\n    /// @return (Rebase) The new total.\r\n    /// @return elastic in relationship to `base`.\r\n    function sub(\r\n        Rebase memory total,\r\n        uint256 base,\r\n        bool roundUp\r\n    ) internal pure returns (Rebase memory, uint256 elastic) {\r\n        elastic = toElastic(total, base, roundUp);\r\n        total.elastic = total.elastic.sub(elastic.to128());\r\n        total.base = total.base.sub(base.to128());\r\n        return (total, elastic);\r\n    }\r\n\r\n    /// @notice Add `elastic` and `base` to `total`.\r\n    function add(\r\n        Rebase memory total,\r\n        uint256 elastic,\r\n        uint256 base\r\n    ) internal pure returns (Rebase memory) {\r\n        total.elastic = total.elastic.add(elastic.to128());\r\n        total.base = total.base.add(base.to128());\r\n        return total;\r\n    }\r\n\r\n    /// @notice Subtract `elastic` and `base` to `total`.\r\n    function sub(\r\n        Rebase memory total,\r\n        uint256 elastic,\r\n        uint256 base\r\n    ) internal pure returns (Rebase memory) {\r\n        total.elastic = total.elastic.sub(elastic.to128());\r\n        total.base = total.base.sub(base.to128());\r\n        return total;\r\n    }\r\n\r\n    /// @notice Add `elastic` to `total` and update storage.\r\n    /// @return newElastic Returns updated `elastic`.\r\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\r\n        newElastic = total.elastic = total.elastic.add(elastic.to128());\r\n    }\r\n\r\n    /// @notice Subtract `elastic` from `total` and update storage.\r\n    /// @return newElastic Returns updated `elastic`.\r\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\r\n        newElastic = total.elastic = total.elastic.sub(elastic.to128());\r\n    }\r\n}\r\n\r\n// File @sushiswap/bentobox-sdk/contracts/IBatchFlashBorrower.sol@v1.0.2\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IBatchFlashBorrower {\r\n    function onBatchFlashLoan(\r\n        address sender,\r\n        IERC20[] calldata tokens,\r\n        uint256[] calldata amounts,\r\n        uint256[] calldata fees,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File @sushiswap/bentobox-sdk/contracts/IFlashBorrower.sol@v1.0.2\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IFlashBorrower {\r\n    function onFlashLoan(\r\n        address sender,\r\n        IERC20 token,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File @sushiswap/bentobox-sdk/contracts/IStrategy.sol@v1.0.2\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IStrategy {\r\n    // Send the assets to the Strategy and call skim to invest them\r\n    function skim(uint256 amount) external;\r\n\r\n    // Harvest any profits made converted to the asset and pass them to the caller\r\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\r\n\r\n    // Withdraw assets. The returned amount can differ from the requested amount due to rounding.\r\n    // The actualAmount should be very close to the amount. The difference should NOT be used to report a loss. That's what harvest is for.\r\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\r\n\r\n    // Withdraw all assets in the safest way possible. This shouldn't fail.\r\n    function exit(uint256 balance) external returns (int256 amountAdded);\r\n}\r\n\r\n// File @sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol@v1.0.2\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IBentoBoxV1 {\r\n    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);\r\n    event LogDeposit(address indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\r\n    event LogFlashLoan(address indexed borrower, address indexed token, uint256 amount, uint256 feeAmount, address indexed receiver);\r\n    event LogRegisterProtocol(address indexed protocol);\r\n    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool approved);\r\n    event LogStrategyDivest(address indexed token, uint256 amount);\r\n    event LogStrategyInvest(address indexed token, uint256 amount);\r\n    event LogStrategyLoss(address indexed token, uint256 amount);\r\n    event LogStrategyProfit(address indexed token, uint256 amount);\r\n    event LogStrategyQueued(address indexed token, address indexed strategy);\r\n    event LogStrategySet(address indexed token, address indexed strategy);\r\n    event LogStrategyTargetPercentage(address indexed token, uint256 targetPercentage);\r\n    event LogTransfer(address indexed token, address indexed from, address indexed to, uint256 share);\r\n    event LogWhiteListMasterContract(address indexed masterContract, bool approved);\r\n    event LogWithdraw(address indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function balanceOf(IERC20, address) external view returns (uint256);\r\n\r\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);\r\n\r\n    function batchFlashLoan(\r\n        IBatchFlashBorrower borrower,\r\n        address[] calldata receivers,\r\n        IERC20[] calldata tokens,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function claimOwnership() external;\r\n\r\n    function deploy(\r\n        address masterContract,\r\n        bytes calldata data,\r\n        bool useCreate2\r\n    ) external payable;\r\n\r\n    function deposit(\r\n        IERC20 token_,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\r\n\r\n    function flashLoan(\r\n        IFlashBorrower borrower,\r\n        address receiver,\r\n        IERC20 token,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function harvest(\r\n        IERC20 token,\r\n        bool balance,\r\n        uint256 maxChangeAmount\r\n    ) external;\r\n\r\n    function masterContractApproved(address, address) external view returns (bool);\r\n\r\n    function masterContractOf(address) external view returns (address);\r\n\r\n    function nonces(address) external view returns (uint256);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function pendingOwner() external view returns (address);\r\n\r\n    function pendingStrategy(IERC20) external view returns (IStrategy);\r\n\r\n    function permitToken(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    function registerProtocol() external;\r\n\r\n    function setMasterContractApproval(\r\n        address user,\r\n        address masterContract,\r\n        bool approved,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    function setStrategy(IERC20 token, IStrategy newStrategy) external;\r\n\r\n    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) external;\r\n\r\n    function strategy(IERC20) external view returns (IStrategy);\r\n\r\n    function strategyData(IERC20)\r\n        external\r\n        view\r\n        returns (\r\n            uint64 strategyStartDate,\r\n            uint64 targetPercentage,\r\n            uint128 balance\r\n        );\r\n\r\n    function toAmount(\r\n        IERC20 token,\r\n        uint256 share,\r\n        bool roundUp\r\n    ) external view returns (uint256 amount);\r\n\r\n    function toShare(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        bool roundUp\r\n    ) external view returns (uint256 share);\r\n\r\n    function totals(IERC20) external view returns (Rebase memory totals_);\r\n\r\n    function transfer(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 share\r\n    ) external;\r\n\r\n    function transferMultiple(\r\n        IERC20 token,\r\n        address from,\r\n        address[] calldata tos,\r\n        uint256[] calldata shares\r\n    ) external;\r\n\r\n    function transferOwnership(\r\n        address newOwner,\r\n        bool direct,\r\n        bool renounce\r\n    ) external;\r\n\r\n    function whitelistMasterContract(address masterContract, bool approved) external;\r\n\r\n    function whitelistedMasterContracts(address) external view returns (bool);\r\n\r\n    function withdraw(\r\n        IERC20 token_,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256 amountOut, uint256 shareOut);\r\n}\r\n\r\n// File contracts/swappers/Leverage/YVIBLevSwapper.sol\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface CurvePool {\r\n    function exchange_underlying(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256 min_dy,\r\n        address receiver\r\n    ) external returns (uint256);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n\r\n    function add_liquidity(\r\n        address pool,\r\n        uint256[4] memory amounts,\r\n        uint256 _min_mint_amount\r\n    ) external returns (uint256);\r\n}\r\n\r\ninterface YearnVault {\r\n    function withdraw() external returns (uint256);\r\n\r\n    function deposit(uint256 amount, address recipient) external returns (uint256);\r\n}\r\n\r\ninterface TetherToken {\r\n    function approve(address _spender, uint256 _value) external;\r\n}\r\n\r\ninterface IConvex is IERC20 {\r\n    function withdrawAndUnwrap(uint256 _amount) external;\r\n\r\n    //deposit a curve token\r\n    function deposit(uint256 _amount, address _to) external;\r\n}\r\n\r\ncontract StkFrax3CrvLevSwapper {\r\n    using BoringMath for uint256;\r\n    using BoringERC20 for IERC20;\r\n\r\n    // Local variables\r\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\r\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\r\n    address public constant FRAX3CRVPOOL = 0xd632f22692FaC7611d2AA1C0D552930D43CAEd3B;\r\n    CurvePool public constant threePool = CurvePool(0xA79828DF1850E8a3A3064576f380D90aECDD3359);\r\n\r\n    IConvex public immutable stkFrax3Crv;\r\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\r\n    IERC20 public constant FRAX3CRV = IERC20(0xd632f22692FaC7611d2AA1C0D552930D43CAEd3B);\r\n\r\n    constructor(IConvex _stkFrax3Crv) public {\r\n        stkFrax3Crv = _stkFrax3Crv;\r\n        MIM.approve(address(MIM3POOL), type(uint256).max);\r\n        TETHER.approve(address(threePool), type(uint256).max);\r\n        FRAX3CRV.approve(address(_stkFrax3Crv), type(uint256).max);\r\n    }\r\n\r\n    // Swaps to a flexible amount, from an exact input amount\r\n    function swap(\r\n        address recipient,\r\n        uint256 shareToMin,\r\n        uint256 shareFrom\r\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\r\n        (uint256 amountFrom, ) = bentoBox.withdraw(MIM, address(this), address(this), 0, shareFrom);\r\n\r\n        uint256 amountUSDT = MIM3POOL.exchange_underlying(0, 3, amountFrom, 0, address(this));\r\n\r\n        // Pool token order is FRAX, DAI, USDC, USDT\r\n        uint256[4] memory amountsAdded = [0, 0, 0, amountUSDT];\r\n        uint256 frax3CrvAmount = threePool.add_liquidity(FRAX3CRVPOOL, amountsAdded, 0);\r\n\r\n        stkFrax3Crv.deposit(frax3CrvAmount, address(bentoBox));\r\n\r\n        (, shareReturned) = bentoBox.deposit(stkFrax3Crv, address(bentoBox), recipient, frax3CrvAmount, 0);\r\n        extraShare = shareReturned.sub(shareToMin);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}